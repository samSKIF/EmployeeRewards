diff --git a/server/routes.original.ts b//dev/null
index eee132cd0d4fb0f7ae1ce4272ab3cce32c240cd8..0000000000000000000000000000000000000000 undefined
--- a/server/routes.original.ts
+++ b//dev/null
@@ -1,3576 +0,0 @@
-import type { Express, Request, Response, NextFunction } from "express";
-import { createServer, type Server } from "http";
-import { storage } from "./storage";
-import { verifyToken, verifyAdmin, AuthenticatedRequest, generateToken } from "./middleware/auth";
-import { tenantRouting, ensureTenantAccess, TenantRequest } from "./middleware/tenant-routing";
-import { scheduleBirthdayRewards } from "./middleware/scheduler";
-import { tilloSupplier, carltonSupplier } from "./middleware/suppliers";
-import { z } from "zod";
-import ExcelJS from 'exceljs';
-import { db, pool } from "./db";
-import { compare, hash } from "bcrypt";
-import { upload, documentUpload, getPublicUrl } from './file-upload';
-// Firebase admin removed - using PostgreSQL authentication only
-// import socialRoutes from './microservices/social/index';
-// import leaveRoutes from './microservices/leave/index';
-// import recognitionRoutes from './microservices/recognition/index';
-// import interestsRoutes from './microservices/interests/index';
-// import employeeStatusRoutes from './microservices/employee-status/index';
-import recognitionAIRoutes from './api/recognition-ai';
-import { CacheService } from './cache/cacheService';
-import { 
-  users, insertUserSchema, 
-  products, insertProductSchema,
-  brandingSettings, insertBrandingSettingsSchema,
-  fileTemplates, insertFileTemplateSchema, FileTemplate,
-  organizations, organizationFeatures,
-  sellers, productCategories, orderItems,
-  supportTickets, ticketMessages, productReviews,
-  posts, comments, reactions, polls, pollVotes, recognitions,
-  interests, employeeInterests,
-  interestChannels, interestChannelMembers, interestChannelPosts, 
-  interestChannelPostComments, interestChannelPostLikes,
-  interestChannelJoinRequests, interestChannelPinnedPosts,
-
-  // Onboarding schemas
-  onboardingPlans, onboardingMissions, onboardingAssignments, onboardingProgress,
-  insertOnboardingPlanSchema, insertOnboardingMissionSchema,
-  insertOnboardingAssignmentSchema, insertOnboardingProgressSchema,
-  OnboardingPlan, OnboardingMission, OnboardingAssignment, OnboardingProgress
-} from "@shared/schema";
-import { eq, desc, asc, and, or, sql, inArray, like } from "drizzle-orm";
-import path from "path";
-
-export async function registerRoutes(app: Express): Promise<Server> {
-  // Register microservices routes (commented out to fix startup issues)
-  // app.use('/api/social', socialRoutes);
-  // app.use('/api/leave', leaveRoutes);
-  // app.use('/api/recognition', recognitionRoutes);
-  // app.use('/api/interests', interestsRoutes);
-  // app.use('/api/employee-status', employeeStatusRoutes);
-  app.use('/api/analytics', recognitionAIRoutes);
-
-  // Direct interests routes for employees (bypass microservice routing issue)
-  app.get('/api/employees/:id/interests', verifyToken, async (req: AuthenticatedRequest, res) => {
-    try {
-      console.log("=== DIRECT ROUTE: GET employee interests ===");
-      const employeeId = parseInt(req.params.id);
-
-      // Import interests schema directly
-      const { interests, employeeInterests } = await import("@shared/schema");
-      const { eq, and, or } = await import("drizzle-orm");
-
-      // Get the current user's ID from the request
-      const currentUserId = req.user?.id;
-      const isCurrentUser = currentUserId === employeeId;
-
-      // Fetch the employee's interests
-      const employeeInterestsData = await db
-        .select({
-          interest: interests,
-          customLabel: employeeInterests.customLabel,
-          isPrimary: employeeInterests.isPrimary,
-          visibility: employeeInterests.visibility
-        })
-        .from(employeeInterests)
-        .innerJoin(interests, eq(employeeInterests.interestId, interests.id))
-        .where(
-          and(
-            eq(employeeInterests.employeeId, employeeId),
-            or(
-              eq(employeeInterests.visibility, "EVERYONE"),
-              isCurrentUser ? sql`TRUE` : sql`FALSE`
-            )
-          )
-        );
-
-      // Format the response
-      const formattedInterests = employeeInterestsData.map(item => ({
-        id: item.interest.id,
-        label: item.customLabel || item.interest.label,
-        category: item.interest.category,
-        icon: item.interest.icon,
-        isPrimary: item.isPrimary,
-        visibility: item.visibility
-      }));
-
-      console.log("Found interests:", formattedInterests.length);
-      res.status(200).json(formattedInterests);
-    } catch (error: any) {
-      console.error("Error fetching employee interests:", error);
-      res.status(500).json({ message: "Failed to fetch interests" });
-    }
-  });
-
-  app.post('/api/employees/:id/interests', verifyToken, async (req: AuthenticatedRequest, res) => {
-    try {
-      console.log("=== DIRECT ROUTE: POST employee interests ===");
-      console.log("Request body:", JSON.stringify(req.body, null, 2));
-
-      const employeeId = parseInt(req.params.id);
-      const currentUserId = req.user?.id;
-
-      // Check authorization
-      if (currentUserId !== employeeId) {
-        return res.status(403).json({ message: "Not authorized to update this employee's interests" });
-      }
-
-      // Import interests schema directly
-      const { interests, employeeInterests } = await import("@shared/schema");
-      const { eq } = await import("drizzle-orm");
-
-      const { interestId } = req.body;
-      console.log('Processing interest', interestId, 'for employee', employeeId);
-
-      // First, get existing interests for this employee
-      const existingInterests = await db
-        .select()
-        .from(employeeInterests)
-        .where(eq(employeeInterests.employeeId, employeeId));
-
-      // Check if this interest is already added
-      const alreadyExists = existingInterests.some(ei => ei.interestId === interestId);
-
-      if (alreadyExists) {
-        return res.status(400).json({ message: 'Interest already added' });
-      }
-
-      // Add the new interest
-      await db.transaction(async (tx) => {
-        await tx
-          .insert(employeeInterests)
-          .values({
-            employeeId: employeeId,
-            interestId: interestId
-          });
-      });
-
-      res.json({ message: 'Interest added successfully' });
-    } catch (error: any) {
-      console.error("Error updating employee interests:", error);
-      res.status(500).json({ message: "Failed to save interests" });
-    }
-  });
-
-  // API endpoint to fetch all available interests
-  app.get('/api/interests', verifyToken, async (req: AuthenticatedRequest, res) => {
-    try {
-      console.log("=== DIRECT ROUTE: GET all available interests ===");
-
-      // Import interests schema directly
-      const { interests } = await import("@shared/schema");
-
-      // Fetch all available interests
-      const allInterests = await db
-        .select()
-        .from(interests);
-
-      console.log('Found', allInterests.length, 'available interests');
-      res.status(200).json(allInterests);
-    } catch (error: any) {
-      console.error("Error fetching available interests:", error);
-      res.status(500).json({ message: "Failed to fetch available interests" });
-    }
-  });
-
-  // Celebrations API - Birthday and Work Anniversary tracking
-  app.get('/api/celebrations/today', verifyToken, async (req: AuthenticatedRequest, res) => {
-    try {
-      const currentUser = req.user;
-      if (!currentUser) {
-        return res.status(401).json({ message: "Unauthorized" });
-      }
-
-      // Get company ID from admin's email domain
-      const domain = currentUser.email.split('@')[1];
-      const domainToCompanyMap: Record<string, number> = {
-        'canva.com': 1,
-        'monday.com': 2, 
-        'loylogic.com': 3,
-        'fripl.com': 4,
-        'democorp.com': 5
-      };
-      const companyId = domainToCompanyMap[domain] || null;
-
-      if (!companyId) {
-        return res.json([]);
-      }
-
-      // Get users with birthdays today from the same organization
-      const birthdayUsers = await db
-        .select()
-        .from(users)
-        .where(
-          and(
-            eq(users.organizationId, companyId),
-            sql`${users.birthDate} IS NOT NULL`,
-            sql`EXTRACT(MONTH FROM ${users.birthDate}) = EXTRACT(MONTH FROM CURRENT_DATE)`,
-            sql`EXTRACT(DAY FROM ${users.birthDate}) = EXTRACT(DAY FROM CURRENT_DATE)`
-          )
-        );
-
-      // Get users with work anniversaries today from the same organization
-      const anniversaryUsers = await db
-        .select()
-        .from(users)
-        .where(
-          and(
-            eq(users.organizationId, companyId),
-            sql`${users.hireDate} IS NOT NULL`,
-            sql`EXTRACT(MONTH FROM ${users.hireDate}) = EXTRACT(MONTH FROM CURRENT_DATE)`,
-            sql`EXTRACT(DAY FROM ${users.hireDate}) = EXTRACT(DAY FROM CURRENT_DATE)`
-          )
-        );
-
-      const todayDate = new Date();
-
-      console.log('Birthday users found:', birthdayUsers.length);
-      console.log('Anniversary users found:', anniversaryUsers.length);
-
-      const celebrations = [
-        ...birthdayUsers.map(employee => ({
-          id: employee.id,
-          user: {
-            id: employee.id,
-            name: employee.name,
-            surname: employee.surname,
-            avatarUrl: employee.photoUrl,
-            department: employee.department,
-            location: employee.location,
-            birthDate: employee.dateOfBirth,
-            hireDate: employee.dateJoined,
-            jobTitle: employee.jobTitle
-          },
-          type: 'birthday',
-          date: todayDate.toISOString().split('T')[0],
-          hasReacted: false,
-          hasCommented: false
-        })),
-        ...anniversaryUsers.map(employee => {
-          const years = employee.dateJoined ? new Date().getFullYear() - new Date(employee.dateJoined).getFullYear() : 0;
-          return {
-            id: employee.id,
-            user: {
-              id: employee.id,
-              name: employee.name,
-              surname: employee.surname,
-              avatarUrl: employee.photoUrl,
-              department: employee.department,
-              location: employee.location,
-              birthDate: employee.dateOfBirth,
-              hireDate: employee.dateJoined,
-              jobTitle: employee.jobTitle
-            },
-            type: 'work_anniversary',
-            date: todayDate.toISOString().split('T')[0],
-            yearsOfService: years,
-            hasReacted: false,
-            hasCommented: false
-          };
-        })
-      ];
-
-      console.log('Total celebrations returning:', celebrations.length);
-      res.json(celebrations);
-    } catch (error) {
-      console.error('Error fetching today\'s celebrations:', error);
-      res.status(500).json({ error: 'Failed to fetch celebrations' });
-    }
-  });
-
-  app.get('/api/celebrations/upcoming', verifyToken, async (req: AuthenticatedRequest, res) => {
-    try {
-      const currentUser = req.user;
-      if (!currentUser) {
-        return res.status(401).json({ message: "Unauthorized" });
-      }
-
-      // Get company ID from admin's email domain
-      const domain = currentUser.email.split('@')[1];
-      const domainToCompanyMap: Record<string, number> = {
-        'canva.com': 1,
-        'monday.com': 2, 
-        'loylogic.com': 3,
-        'fripl.com': 4,
-        'democorp.com': 5
-      };
-      const companyId = domainToCompanyMap[domain] || null;
-
-      if (!companyId) {
-        return res.json([]);
-      }
-
-      const celebrations = [];
-
-      // Check next 5 days
-      for (let i = 1; i <= 5; i++) {
-        const targetDate = new Date();
-        targetDate.setDate(targetDate.getDate() + i);
-        const month = targetDate.getMonth() + 1;
-        const day = targetDate.getDate();
-
-        // Get birthdays for this date from the same organization
-        const birthdayUsers = await db
-          .select()
-          .from(users)
-          .where(
-            and(
-              eq(users.organizationId, companyId),
-              sql`${users.birthDate} IS NOT NULL`,
-              sql`EXTRACT(MONTH FROM ${users.birthDate}) = ${month}`,
-              sql`EXTRACT(DAY FROM ${users.birthDate}) = ${day}`
-            )
-          );
-
-        // Get work anniversaries for this date from the same organization
-        const anniversaryUsers = await db
-          .select()
-          .from(users)
-          .where(
-            and(
-              eq(users.organizationId, companyId),
-              sql`${users.hireDate} IS NOT NULL`,
-              sql`EXTRACT(MONTH FROM ${users.hireDate}) = ${month}`,
-              sql`EXTRACT(DAY FROM ${users.hireDate}) = ${day}`
-            )
-          );
-
-        celebrations.push(
-          ...birthdayUsers.map(user => ({
-            id: user.id,
-            user: {
-              id: user.id,
-              name: user.name,
-              surname: user.surname,
-              avatarUrl: user.avatarUrl,
-              department: user.department,
-              location: user.location,
-              birthDate: user.birthDate,
-              hireDate: user.hireDate,
-              jobTitle: user.jobTitle
-            },
-            type: 'birthday',
-            date: targetDate.toISOString().split('T')[0],
-            hasReacted: false,
-            hasCommented: false
-          })),
-          ...anniversaryUsers.map(user => {
-            const years = user.hireDate ? targetDate.getFullYear() - new Date(user.hireDate).getFullYear() : 0;
-            return {
-              id: user.id,
-              user: {
-                id: user.id,
-                name: user.name,
-                surname: user.surname,
-                avatarUrl: user.avatarUrl,
-                department: user.department,
-                location: user.location,
-                birthDate: user.birthDate,
-                hireDate: user.hireDate,
-                jobTitle: user.jobTitle
-              },
-              type: 'work_anniversary',
-              date: targetDate.toISOString().split('T')[0],
-              yearsOfService: years,
-              hasReacted: false,
-              hasCommented: false
-            };
-          })
-        );
-      }
-
-      // Sort by date
-      celebrations.sort((a, b) => new Date(a.date).getTime() - new Date(b.date).getTime());
-
-      res.json(celebrations);
-    } catch (error) {
-      console.error('Error fetching upcoming celebrations:', error);
-      res.status(500).json({ error: 'Failed to fetch upcoming celebrations' });
-    }
-  });
-
-  app.get('/api/celebrations/extended', verifyToken, async (req: AuthenticatedRequest, res) => {
-    try {
-      const { department, location } = req.query;
-      console.log('Extended celebrations API called with filters:', { department, location });
-      const celebrations = [];
-
-      // Check last 5 days, today, and next 5 days
-      for (let i = -5; i <= 5; i++) {
-        const targetDate = new Date();
-        targetDate.setDate(targetDate.getDate() + i);
-        const month = targetDate.getMonth() + 1;
-        const day = targetDate.getDate();
-
-        // Build query conditions
-        let birthdayConditions = [
-          sql`${users.birthDate} IS NOT NULL`,
-          sql`EXTRACT(MONTH FROM ${users.birthDate}) = ${month}`,
-          sql`EXTRACT(DAY FROM ${users.birthDate}) = ${day}`
-        ];
-
-        let anniversaryConditions = [
-          sql`${users.hireDate} IS NOT NULL`,
-          sql`EXTRACT(MONTH FROM ${users.hireDate}) = ${month}`,
-          sql`EXTRACT(MONTH FROM ${users.hireDate}) = ${month}`,
-          sql`EXTRACT(DAY FROM ${users.hireDate}) = ${day}`
-        ];
-
-        // Add filters if specified
-        if (department && department !== 'all') {
-          birthdayConditions.push(eq(users.department, department as string));
-          anniversaryConditions.push(eq(users.department, department as string));
-        }
-
-        if (location && location !== 'all') {
-          birthdayConditions.push(eq(users.location, location as string));
-          anniversaryConditions.push(eq(users.location, location as string));
-        }
-
-        if (location && location !== 'all') {
-          birthdayConditions.push(eq(users.location, location as string));
-          anniversaryConditions.push(eq(users.location, location as string));
-        }
-
-        // Get birthdays for this date
-        const birthdayUsers = await db
-          .select()
-          .from(users)
-          .where(and(...birthdayConditions));
-
-        // Get work anniversaries for this date
-        const anniversaryUsers = await db
-          .select()
-          .from(users)
-          .where(and(...anniversaryConditions));
-
-        celebrations.push(
-          ...birthdayUsers.map(user => ({
-            id: user.id,
-            user: {
-              id: user.id,
-              name: user.name,
-              surname: user.surname,
-              avatarUrl: user.avatarUrl,
-              department: user.department,
-              location: user.location,
-              birthDate: user.birthDate,
-              hireDate: user.hireDate,
-              jobTitle: user.jobTitle
-            },
-            type: 'birthday',
-            date: targetDate.toISOString().split('T')[0],
-            hasReacted: false,
-            hasCommented: false
-          })),
-          ...anniversaryUsers.map(user => {
-            const years = user.hireDate ? targetDate.getFullYear() - new Date(user.hireDate).getFullYear() : 0;
-            return {
-              id: user.id,
-              user: {
-                id: user.id,
-                name: user.name,
-                surname: user.surname,
-                avatarUrl: user.avatarUrl,
-                department: user.department,
-                location: user.location,
-                birthDate: user.birthDate,
-                hireDate: user.hireDate,
-                jobTitle: user.jobTitle
-              },
-              type: 'work_anniversary',
-              date: targetDate.toISOString().split('T')[0],
-              yearsOfService: years,
-              hasReacted: false,
-              hasCommented: false
-            };
-          })
-        );
-      }
-
-      // Sort by date
-      celebrations.sort((a, b) => new Date(a.date).getTime() - new Date(b.date).getTime());
-
-      res.json(celebrations);
-    } catch (error) {
-      console.error('Error fetching extended celebrations:', error);
-      res.status(500).json({ error: 'Failed to fetch extended celebrations' });
-    }
-  });
-
-  app.get('/api/users/departments', verifyToken, async (req: AuthenticatedRequest, res) => {
-    try {
-      const orgId = req.user?.organizationId || 1;
-
-      const departments = await CacheService.getOrSet(
-        CacheService.KEYS.DEPARTMENTS(orgId),
-        async () => {
-          const result = await db
-            .selectDistinct({ department: users.department })
-            .from(users)
-            .where(sql`${users.department} IS NOT NULL`);
-
-          return result
-            .map(row => row.department)
-            .filter(dept => dept && dept.trim() !== '')
-            .sort();
-        },
-        CacheService.EXPIRATION.DEPARTMENTS
-      );
-
-      res.json(departments);
-    } catch (error) {
-      console.error('Error fetching departments:', error);
-      res.status(500).json({ error: 'Failed to fetch departments' });
-    }
-  });
-
-  app.get('/api/users/locations', verifyToken, async (req: AuthenticatedRequest, res) => {
-    try {
-      const orgId = req.user?.organizationId || 1;
-
-      const locations = await CacheService.getOrSet(
-        CacheService.KEYS.LOCATIONS(orgId),
-        async () => {
-          const result = await db
-            .selectDistinct({ location: users.location })
-            .from(users)
-            .where(sql`${users.location} IS NOT NULL`);
-
-          return result
-            .map(row => row.location)
-            .filter(location => location && location.trim() !== '')
-            .sort();
-        },
-        CacheService.EXPIRATION.LOCATIONS
-      );
-
-      res.json(locations);
-    } catch (error) {
-      console.error('Error fetching locations:', error);
-      res.status(500).json({ error: 'Failed to fetch locations' });
-    }
-  });
-  // Create corporate admin account
-  app.post("/api/admin/corporate-account", async (req, res) => {
-    try {
-      const { email, password, name, username } = req.body;
-      console.log("Attempting to create corporate admin account:", { email, name, username });
-
-      if (!email || !password || !name || !username) {
-        console.log("Missing required fields");
-        return res.status(400).json({ message: "Missing required fields" });
-      }
-
-      // Check if email already exists
-      const existingEmailUser = await storage.getUserByEmail(email);
-      if (existingEmailUser) {
-        console.log("Email already registered:", email);
-        return res.status(409).json({ message: "Email already registered" });
-      }
-
-      // Check if username already exists
-      const [existingUsernameUser] = await db.select().from(users).where(eq(users.username, username));
-      if (existingUsernameUser) {
-        console.log("Username already taken:", username);
-        return res.status(409).json({ message: "Username already taken" });
-      }
-
-      // Get the corporate organization
-      const orgsResult = await pool.query(`
-        SELECT * FROM organizations WHERE type = 'corporate' LIMIT 1
-      `);
-      console.log("Found corporate organizations:", orgsResult.rows);
-
-      let corporateOrg = orgsResult.rows[0];
-
-      if (!corporateOrg) {
-        console.log("No corporate organization found, creating one");
-        const newOrgResult = await pool.query(`
-          INSERT INTO organizations (name, type, status)
-          VALUES ('ThrivioHR Corporate', 'corporate', 'active')
-          RETURNING *
-        `);
-
-        corporateOrg = newOrgResult.rows[0];
-        console.log("Created corporate organization:", corporateOrg);
-      }
-
-      // Hash the password
-      const hashedPassword = await hash(password, 10);
-      console.log("Password hashed successfully");
-
-      console.log("Inserting corporate admin user with values:", {
-        email,
-        username,
-        name,
-        isAdmin: true,
-        role_type: "corporate_admin",
-        organization_id: corporateOrg.id
-      });
-
-      // Create the user with corporate_admin role
-      // Use SQL directly to avoid type errors
-      const result = await pool.query(`
-        INSERT INTO users (
-          email, username, password, name, 
-          "is_admin", role_type, organization_id, 
-          permissions, status
-        ) 
-        VALUES (
-          $1, $2, $3, $4, 
-          $5, $6, $7, 
-          $8, $9
-        )
-        RETURNING *
-      `, [
-        email, 
-        username, 
-        hashedPassword, 
-        name, 
-        true, 
-        "corporate_admin", 
-        corporateOrg.id, 
-        JSON.stringify({
-          manage_clients: true,
-          manage_marketplace: true,
-          manage_features: true
-        }),
-        "active"
-      ]);
-
-      const newUser = result.rows[0];
-      console.log("Corporate admin user created successfully:", {
-        id: newUser.id,
-        email: newUser.email,
-        username: newUser.username,
-        role_type: newUser.role_type
-      });
-
-      // Return success with user data (excluding password)
-      const userWithoutPassword = { ...newUser, password: undefined };
-      return res.status(201).json(userWithoutPassword);
-    } catch (error) {
-      console.error("Error creating corporate admin account:", error);
-      return res.status(500).json({ message: "Internal server error", error: error.message });
-    }
-  });
-
-  // Verify corporate admin access
-  app.get("/api/admin/corporate/check", verifyToken, async (req: AuthenticatedRequest, res) => {
-    try {
-      if (!req.user) {
-        return res.status(401).json({ message: "Unauthorized" });
-      }
-
-      // Check if the user is a corporate admin
-      if (req.user.roleType !== "corporate_admin") {
-        return res.status(403).json({ message: "Forbidden: Corporate admin access required" });
-      }
-
-      res.json({ isCorporateAdmin: true });
-    } catch (error: any) {
-      console.error("Error checking corporate admin:", error);
-      res.status(500).json({ message: error.message || "Error checking corporate admin status" });
-    }
-  });
-
-  // Get all organizations (clients)
-  app.get("/api/admin/organizations", verifyToken, async (req: AuthenticatedRequest, res) => {
-    try {
-      if (!req.user) {
-        return res.status(401).json({ message: "Unauthorized" });
-      }
-
-      // Check if the user is a corporate admin
-      if (req.user.roleType !== "corporate_admin") {
-        return res.status(403).json({ message: "Forbidden: Corporate admin access required" });
-      }
-
-      // Query all organizations that are not corporate
-      const result = await pool.query(`
-        SELECT 
-          o.*, 
-          (SELECT COUNT(*) FROM users WHERE organization_id = o.id) as user_count 
-        FROM organizations o 
-        WHERE o.type != 'corporate'
-        ORDER BY o.created_at DESC
-      `);
-
-      const organizations = result.rows;
-
-      res.json(organizations);
-    } catch (error: any) {
-      console.error("Error getting organizations:", error);
-      res.status(500).json({ message: error.message || "Error retrieving organizations" });
-    }
-  });
-
-  // Create a new organization (client)
-  app.post("/api/admin/organizations", verifyToken, async (req: AuthenticatedRequest, res) => {
-    try {
-      if (!req.user) {
-        return res.status(401).json({ message: "Unauthorized" });
-      }
-
-      // Check if the user is a corporate admin
-      if (req.user.roleType !== "corporate_admin") {
-        return res.status(403).json({ message: "Forbidden: Corporate admin access required" });
-      }
-
-      const { name, type, status } = req.body;
-
-      if (!name || !type) {
-        return res.status(400).json({ message: "Name and type are required" });
-      }
-
-      // Create the new organization
-      const result = await pool.query(`
-        INSERT INTO organizations (name, type, status)
-        VALUES ($1, $2, $3)
-        RETURNING *
-      `, [
-        name,
-        type,
-        status || 'active'
-      ]);
-
-      const newOrganization = result.rows[0];
-
-      // Create the organization features (enable all by default)
-      try {
-        await pool.query(`
-          INSERT INTO organization_features (organization_id, feature_name, is_enabled)
-          VALUES 
-            ($1, 'shop', true),
-            ($1, 'social', true),
-            ($1, 'surveys', true),
-            ($1, 'hr', true)
-        `, [newOrganization.id]);
-      } catch (featureError: any) {
-        console.error("Error adding organization features:", featureError);
-        // Don't throw the error - we want the organization to be created even if features fail
-      }
-
-      res.status(201).json(newOrganization);
-    } catch (error: any) {
-      console.error("Error creating organization:", error);
-      res.status(500).json({ message: error.message || "Error creating organization" });
-    }
-  });
-  // Registration endpoint
-  app.post("/api/auth/register", async (req, res) => {
-    try {
-      console.log("REGISTRATION ATTEMPT - Raw body:", req.body);
-
-      // Check if this is a Firebase user registration
-      const { firebaseUid, firebaseUser, ...userData } = req.body;
-
-      // Validate user data using the insertUserSchema (or a subset for Firebase users)
-      if (firebaseUid && firebaseUser) {
-        // This is a Firebase user registration
-        console.log("Processing Firebase user registration", firebaseUser);
-
-        // Check if email already exists
-        const existingEmailUser = await storage.getUserByEmail(firebaseUser.email);
-        if (existingEmailUser) {
-          return res.status(409).json({ message: "Email already registered" });
-        }
-
-        // Create username from email if not provided
-        const username = userData.username || firebaseUser.email.split('@')[0];
-
-        // Check if username already exists
-        const [existingUsernameUser] = await db.select().from(users).where(eq(users.username, username));
-        if (existingUsernameUser) {
-          return res.status(409).json({ message: "Username already taken" });
-        }
-
-        // Create user with data from Firebase and form
-        const user = await storage.createUser({
-          ...userData,
-          email: firebaseUser.email,
-          username: username,
-          name: firebaseUser.displayName?.split(' ')[0] || username,
-          surname: firebaseUser.displayName?.split(' ').slice(1).join(' ') || '',
-          // Set a random password since Firebase handles auth
-          password: await hash(Math.random().toString(36).substring(2, 15), 10),
-          isAdmin: false, // Firebase users can't be admins by default
-          status: 'active',
-          firebaseUid // Store the Firebase UID for future reference
-        });
-
-        // Remove password from response
-        const { password: _, ...userWithoutPassword } = user;
-
-        console.log("Firebase user registration successful for:", userWithoutPassword);
-
-        res.status(201).json({
-          user: userWithoutPassword
-        });
-      } else {
-        // This is a regular user registration
-        // Validate user data
-        const validatedUserData = insertUserSchema.parse(userData);
-
-        // Check if email already exists
-        const existingEmailUser = await storage.getUserByEmail(validatedUserData.email);
-        if (existingEmailUser) {
-          return res.status(409).json({ message: "Email already registered" });
-        }
-
-        // Check if username already exists
-        const [existingUsernameUser] = await db.select().from(users).where(eq(users.username, validatedUserData.username));
-        if (existingUsernameUser) {
-          return res.status(409).json({ message: "Username already taken" });
-        }
-
-        // PostgreSQL authentication only - no Firebase dependency
-        console.log(`Creating user in PostgreSQL database: ${validatedUserData.email}`);
-
-        // Create the user in the database
-        const user = await storage.createUser(validatedUserData);
-
-        // Remove password from response
-        const { password: _, ...userWithoutPassword } = user;
-
-        // Generate JWT token for automatic login (for backward compatibility)
-        const token = generateToken({
-          id: user.id,
-          username: user.username,
-          name: user.name,
-          surname: user.surname,
-          email: user.email,
-          phoneNumber: user.phoneNumber,
-          jobTitle: user.jobTitle,
-          department: user.department,
-          sex: user.sex,
-          nationality: user.nationality,
-          birthDate: user.birthDate,
-          isAdmin: user.isAdmin,
-          status: user.status,
-          avatarUrl: user.avatarUrl,
-          hireDate: user.hireDate,
-          createdAt: user.createdAt
-        });
-
-        console.log("Standard registration successful for:", userWithoutPassword);
-
-        res.status(201).json({
-          token,
-          user: userWithoutPassword
-        });
-      }
-    } catch (error: any) {
-      console.error("Registration error:", error);
-      res.status(400).json({ message: error.message || "Registration failed"});
-    }
-  });
-
-    // Authentication routes with tenant routing
-  app.post("/api/auth/login", async (req, res) => {
-    try {
-      console.log("LOGIN ATTEMPT - Raw body:", req.body);
-
-      // Handle both email and username login attempts
-      const { email, username, password } = req.body;
-
-      if ((!email && !username) || !password) {
-        console.log("Missing authentication credentials");
-        return res.status(400).json({ message: "Email/username and password are required" });
-      }
-
-      let user = null;
-      let tenantDb = null;
-
-      // If email is provided, look up user directly in main database
-      if (email) {
-        console.log(`Looking up user with email: ${email}`);
-
-        // Look up user directly in the main database (case-insensitive)
-        const [foundUser] = await db.select().from(users).where(sql`LOWER(${users.email}) = LOWER(${email})`);
-        user = foundUser;
-
-        if (user) {
-          console.log(`User found in main database: ${user.email}`);
-        } else {
-          console.log(`No user found with email: ${email}`);
-        }
-      }
-
-      // Fallback to main database for username lookup
-      if (!user && username) {
-        console.log(`Looking up user with username: ${username}`);
-        const [foundUser] = await db.select().from(users).where(eq(users.username, username));
-        user = foundUser;
-      }
-
-      if (!user) {
-        console.log("No user found with provided credentials");
-        return res.status(401).json({ message: "Invalid credentials" });
-      }
-
-      console.log(`User found: ${user.username}, verifying password`);
-      console.log("Stored password hash:", user.password);
-      console.log("Provided password:", password);
-
-      const passwordMatch = await storage.verifyPassword(password, user.password);
-
-      console.log("Password verification result:", passwordMatch);
-
-      if (!passwordMatch) {
-        console.log("Password verification failed");
-        return res.status(401).json({ message: "Invalid credentials" });
-      }
-
-      console.log("Password verified, generating token");
-
-      // Update last seen timestamp on successful authentication
-      try {
-        await db.update(users)
-          .set({ lastSeenAt: new Date() })
-          .where(eq(users.id, user.id));
-        console.log(`Updated last seen for user ${user.id}`);
-      } catch (error) {
-        console.log("Failed to update last seen on login:", error);
-      }
-
-      // Create JWT token
-      const token = generateToken({
-        id: user.id,
-        username: user.username,
-        name: user.name,
-        surname: user.surname,
-        email: user.email,
-        phoneNumber: user.phoneNumber,
-        jobTitle: user.jobTitle,
-        department: user.department,
-        sex: user.sex,
-        nationality: user.nationality,
-        birthDate: user.birthDate,
-        isAdmin: user.isAdmin,
-        status: user.status,
-        avatarUrl: user.avatarUrl,
-        hireDate: user.hireDate,
-        createdAt: user.createdAt
-      });
-
-      // Don't send the password back to the client
-      const { password: _, ...userWithoutPassword } = user;
-
-      console.log("Login successful for:", userWithoutPassword);
-      console.log("Generated token:", token.substring(0, 20) + "...");
-
-      res.status(200).json({
-        token,
-        user: userWithoutPassword
-      });
-    } catch (error: any) {
-      console.error("Login error:", error);
-      res.status(500).json({ message: error.message || "An error occurred during login" });
-    }
-  });
-
-  // Points ledger routes
-  app.post("/api/points/earn", verifyToken, verifyAdmin, async (req: AuthenticatedRequest, res) => {
-    try {
-      const { userId, amount, reason, description } = req.body;
-
-      if (!userId || !amount || !reason || !description) {
-        return res.status(400).json({ message: "Missing required fields" });
-      }
-
-      const adminId = req.user?.id;
-
-      // Award points to the user
-      const transaction = await storage.earnPoints(userId, amount, reason, description, adminId);
-
-      // Get updated balance
-      const balance = await storage.getUserBalance(userId);
-
-      res.json({
-        transaction,
-        balance
-      });
-    } catch (error: any) {
-      res.status(500).json({ message: error.message || "Failed to award points" });
-    }
-  });
-
-  app.post("/api/points/redeem", verifyToken, async (req: AuthenticatedRequest, res) => {
-    try {
-      if (!req.user) {
-        return res.status(401).json({ message: "Unauthorized" });
-      }
-
-      const { amount, productId, description } = req.body;
-
-      if (!amount || !productId || !description) {
-        return res.status(400).json({ message: "Missing required fields" });
-      }
-
-      // Redeem points for the product
-      const { transaction, order } = await storage.redeemPoints(
-        req.user.id,
-        amount,
-        description,
-        productId
-      );
-
-      // Get updated balance
-      const balance = await storage.getUserBalance(req.user.id);
-
-      res.json({
-        transaction,
-        order,
-        balance
-      });
-    } catch (error: any) {
-      res.status(500).json({ message: error.message || "Failed to redeem points" });
-    }
-  });
-
-  app.get("/api/points/balance", verifyToken, async (req: AuthenticatedRequest, res) => {
-    try {
-      if (!req.user) {
-        return res.status(401).json({ message: "Unauthorized" });
-      }
-
-      const balance = await storage.getUserBalance(req.user.id);
-
-      res.json({
-        balance,
-        userId: req.user.id
-      });
-    } catch (error: any) {
-      res.status(500).json({ message: error.message || "Failed to get balance" });
-    }
-  });
-
-  // User routes
-  app.get("/api/users/me", verifyToken, async (req: AuthenticatedRequest, res) => {
-    try {
-      if (!req.user) {
-        return res.status(401).json({ message: "Unauthorized" });
-      }
-
-      console.log(`/api/users/me: Returning data for user ${req.user.id} (${req.user.name}, ${req.user.email})`);
-      console.log(`User isAdmin value: ${req.user.isAdmin}`);
-
-      // Firebase authentication removed - using PostgreSQL authentication only
-
-      // Update lastSeenAt timestamp for ongoing activity tracking
-      try {
-        await db.update(users)
-          .set({ lastSeenAt: new Date() })
-          .where(eq(users.id, req.user.id));
-      } catch (error) {
-        console.log("Failed to update lastSeenAt:", error);
-      }
-
-      // Fetch fresh user data from database to include any recent updates (like avatarUrl)
-      const [freshUser] = await db.select().from(users).where(eq(users.id, req.user.id));
-
-      if (!freshUser) {
-        return res.status(404).json({ message: "User not found" });
-      }
-
-      // Get the user's balance
-      const balance = await storage.getUserBalance(req.user.id);
-
-      // Combine fresh user data with balance, ensuring isAdmin is explicitly set
-      const userWithBalance = {
-        ...freshUser,
-        isAdmin: freshUser.isAdmin === true, // Ensure boolean false for non-admins
-        balance
-      };
-
-      console.log(`Final user object isAdmin: ${userWithBalance.isAdmin}`);
-      res.json(userWithBalance);
-    } catch (error: any) {
-      console.error("Error getting user data:", error);
-      res.status(500).json({ message: error.message || "Failed to get user" });
-    }
-  });
-
-  // Update user profile
-  app.patch("/api/users/me", verifyToken, async (req: AuthenticatedRequest, res) => {
-    try {
-      if (!req.user) {
-        return res.status(401).json({ message: "Unauthorized" });
-      }
-
-      // Get fields to update from the request body
-      const { name, title, department, location, responsibilities, aboutMe, avatarUrl } = req.body;
-
-      // Build update object with only provided fields
-      const updateData: any = {};
-      if (name !== undefined) updateData.name = name;
-      if (title !== undefined) updateData.jobTitle = title;
-      if (department !== undefined) updateData.department = department;
-      if (location !== undefined) updateData.location = location;
-      if (responsibilities !== undefined) updateData.responsibilities = responsibilities;
-      if (aboutMe !== undefined) updateData.aboutMe = aboutMe;
-      if (avatarUrl !== undefined) updateData.avatarUrl = avatarUrl;
-
-      // Update user in database
-      const [updatedUser] = await db
-        .update(users)
-        .set(updateData)
-        .where(eq(users.id, req.user.id))
-        .returning();
-
-      if (!updatedUser) {
-        return res.status(404).json({ message: "User not found" });
-      }
-
-      // Get the user's balance
-      const balance = await storage.getUserBalance(req.user.id);
-
-      // Combine user data with balance
-      const userWithBalance = {
-        ...updatedUser,
-        balance
-      };
-
-      res.json(userWithBalance);
-    } catch (error: any) {
-      console.error("Error updating user profile:", error);
-      res.status(500).json({ message: error.message || "Failed to update user profile" });
-    }
-  });
-
-  // Upload user avatar
-  app.post("/api/users/avatar", verifyToken, async (req: AuthenticatedRequest, res) => {
-    try {
-      if (!req.user) {
-        return res.status(401).json({ message: "Unauthorized" });
-      }
-
-      // For demonstration, we'll accept a base64 image URL
-      const { avatarUrl } = req.body;
-
-      if (!avatarUrl) {
-        return res.status(400).json({ message: "No avatar image provided" });
-      }
-
-      // In a real implementation, we would save the image to storage
-      // and update the database with the image URL
-
-      // Update user with the avatar URL in the database
-      try {
-        // Update the user record in the database
-        const [updatedUser] = await db.update(users)
-          .set({ avatarUrl })
-          .where(eq(users.id, req.user.id))
-          .returning();
-
-        // Return the updated user
-        res.json({
-          message: "Avatar updated successfully",
-          user: updatedUser
-        });
-      } catch (dbError) {
-        console.error("Database error updating avatar:", dbError);
-
-        // Fallback: If database update fails, still return the user with updated avatar
-        // This ensures the UI can still update even if persistence fails
-        const updatedUser = {
-          ...req.user,
-          avatarUrl
-        };
-
-        res.json({
-          message: "Avatar updated successfully (local only)",
-          user: updatedUser
-        });
-      }
-    } catch (error: any) {
-      console.error("Error updating user avatar:", error);
-      res.status(500).json({ message: error.message || "Failed to update avatar" });
-    }
-  });
-
-  // Upload user cover photo
-  app.post("/api/users/cover-photo", verifyToken, async (req: AuthenticatedRequest, res) => {
-    try {
-      if (!req.user) {
-        return res.status(401).json({ message: "Unauthorized" });
-      }
-
-      // Accept a base64 image URL
-      const { coverPhotoUrl } = req.body;
-
-      if (!coverPhotoUrl) {
-        return res.status(400).json({ message: "No cover photo provided" });
-      }
-
-      // Try updating the database first
-      try {
-        // NOTE: This will fail until the database migration is completed
-        const [updatedUser] = await db.update(users)
-          .set({ coverPhotoUrl })
-          .where(eq(users.id, req.user.id))
-          .returning();
-
-        return res.json({
-          message: "Cover photo updated successfully",
-          user: updatedUser
-        });
-      } catch (dbError) {
-        console.error("Database error updating cover photo:", dbError);
-
-        // Fallback: Return a successful response even if the DB update fails
-        // This allows the UI to show the changes until the migration is complete
-        const updatedUser = {
-          ...req.user,
-          coverPhotoUrl
-        };
-
-        res.json({
-          message: "Cover photo updated (local only)",
-          user: updatedUser
-        });
-      }
-    } catch (error: any) {
-      console.error("Error updating cover photo:", error);
-      res.status(500).json({ message: error.message || "Failed to update cover photo" });
-    }
-  });
-
-  // Save user metadata from Firebase auth
-  app.post("/api/users/metadata", async (req, res) => {
-    try {
-      console.log("Received user metadata:", req.body);
-      const { email, name, username, department, firebaseUid } = req.body;
-
-      if (!email) {
-        return res.status(400).json({ message: "Email is required" });
-      }
-
-      // Check if user already exists with this email
-      const existingUser = await storage.getUserByEmail(email);
-
-      // If user exists, just update the Firebase UID
-      if (existingUser) {
-        console.log("User already exists, updating Firebase UID", existingUser.id);
-
-        // Update the user's firebaseUid in the database and set admin status if needed
-        const isAdmin = email === 'admin@demo.io';
-
-        await db.update(users)
-          .set({ 
-            firebaseUid: firebaseUid || null,
-            // Only set to true for admin email, never change existing admins to false
-            ...(isAdmin ? { isAdmin: true } : {})
-          })
-          .where(eq(users.id, existingUser.id));
-
-        return res.status(200).json({ 
-          message: "User updated with Firebase UID", 
-          user: existingUser 
-        });
-      }
-
-      // Otherwise create a new user
-      console.log("Creating new user from Firebase auth");
-      const defaultPassword = await hash(Math.random().toString(36).slice(2), 10);
-
-      // Special case: Consider admin@demo.io to be an admin user
-      const isAdmin = email === 'admin@demo.io';
-
-      const userData = {
-        email,
-        name: name || email.split('@')[0],
-        username: username || email.split('@')[0],
-        department: department || null,
-        password: defaultPassword,
-        firebaseUid: firebaseUid || null,
-        isAdmin: false // Always create employees as regular users, admin promotion happens separately
-      };
-
-      const newUser = await storage.createUser(userData);
-
-      res.status(201).json({ 
-        message: "User metadata saved", 
-        user: newUser 
-      });
-    } catch (error: any) {
-      console.error("Error saving user metadata:", error);
-      res.status(500).json({ message: error.message || "Failed to save user metadata" });
-    }
-  });
-
-  // Check for duplicate users endpoint
-  app.post("/api/users/check-duplicate", verifyToken, verifyAdmin, async (req: AuthenticatedRequest, res) => {
-    try {
-      const { email, name, surname } = req.body;
-
-      if (!email) {
-        return res.status(400).json({ message: "Email is required" });
-      }
-
-      const duplicateCheck = await storage.checkDuplicateUser(email, name, surname);
-      
-      res.json(duplicateCheck);
-    } catch (error: any) {
-      console.error("Error checking duplicates:", error);
-      res.status(500).json({ message: error.message || "Failed to check duplicates" });
-    }
-  });
-
-  app.get("/api/users", verifyToken, verifyAdmin, async (req: AuthenticatedRequest, res) => {
-    try {
-      const currentUser = req.user;
-      if (!currentUser) {
-        return res.status(401).json({ message: "Unauthorized" });
-      }
-
-      // Get company ID from admin's email domain
-      const domain = currentUser.email.split('@')[1];
-
-      // Find the company ID by matching domain
-      let companyId: number | null = null;
-
-      // Map known domains to company IDs (based on our setup data)
-      const domainToCompanyMap: Record<string, number> = {
-        'canva.com': 1,
-        'monday.com': 2, 
-        'loylogic.com': 3,
-        'fripl.com': 4,
-        'democorp.com': 5
-      };
-
-      companyId = domainToCompanyMap[domain] || null;
-
-      let filteredUsers = [];
-
-      if (companyId) {
-        // Get employees from the same company
-        const employeesFromCompany = await db.select()
-          .from(users)
-          .where(eq(users.organizationId, companyId));
-
-        // Get admins from the same domain
-        const adminsFromCompany = await db.select()
-          .from(users)
-          .where(like(users.email, `%${domain}`));
-
-        filteredUsers = [...adminsFromCompany, ...employeesFromCompany];
-      } else {
-        // Fallback: get all users (for development)
-        filteredUsers = await db.select().from(users);
-      }
-
-      // Get balances for filtered users
-      const usersWithBalance = await Promise.all(filteredUsers.map(async (user) => {
-        const balance = await storage.getUserBalance(user.id);
-        // Remove sensitive data like password
-        const { password, ...userWithoutPassword } = user;
-        return {
-          ...userWithoutPassword,
-          balance
-        };
-      }));
-
-      console.log(`Returning ${usersWithBalance.length} users for company ${companyId || 'unknown'}`);
-      res.json(usersWithBalance);
-    } catch (error: any) {
-      console.error("Error getting all users:", error);
-      res.status(500).json({ message: error.message || "Failed to get users" });
-    }
-  });
-
-  // Transaction routes
-  app.get("/api/transactions", verifyToken, async (req: AuthenticatedRequest, res) => {
-    try {
-      if (!req.user) {
-        return res.status(401).json({ message: "Unauthorized" });
-      }
-
-      // Return empty transactions for now until we implement proper DB queries
-      // This allows the app to function without errors
-      const transactions = [];
-
-      res.json(transactions);
-    } catch (error: any) {
-      console.error("Error fetching transactions:", error);
-      res.status(500).json({ message: error.message || "Failed to get transactions" });
-    }
-  });
-
-  // Product routes
-  // Shop Configuration Routes
-  app.get("/api/shop/config", verifyToken, async (req: AuthenticatedRequest, res) => {
-    try {
-      const config = await storage.getShopConfig();
-      res.json(config);
-    } catch (error) {
-      console.error("Error fetching shop config:", error);
-      res.status(500).json({ message: "Failed to fetch shop configuration" });
-    }
-  });
-
-  app.post("/api/shop/config", verifyToken, async (req: AuthenticatedRequest, res) => {
-    try {
-      const config = await storage.updateShopConfig(req.body);
-      res.json(config);
-    } catch (error) {
-      console.error("Error updating shop config:", error);
-      res.status(500).json({ message: "Failed to update shop configuration" });
-    }
-  });
-
-  // Admin endpoint to refresh the product catalog
-  app.post("/api/admin/products/refresh", verifyToken, verifyAdmin, async (req: AuthenticatedRequest, res) => {
-    try {
-      if (!req.user) {
-        return res.status(401).json({ message: "Unauthorized" });
-      }
-
-      console.log("Refreshing product catalog at admin request...");
-
-      // Delete all existing products
-      await storage.deleteAllProducts();
-      console.log("All existing products deleted");
-
-      // Insert all the gift card products
-      const giftCardProducts = [
-        {
-          name: "Amazon Gift Card",
-          description: "$50 Amazon gift card to spend on anything you want.",
-          category: "Gift Cards",
-          points: 400,
-          imageUrl: "https://images.unsplash.com/photo-1584990451792-a664249664bc?w=500&h=300&fit=crop",
-          supplier: "tillo",
-          isActive: true,
-          createdBy: req.user.id
-        },
-        {
-          name: "Starbucks Gift Card",
-          description: "$25 Starbucks gift card for your coffee breaks.",
-          category: "Gift Cards",
-          points: 200,
-          imageUrl: "https://images.unsplash.com/photo-1505373877841-8d25f7d46678?w=500&h=300&fit=crop",
-          supplier: "tillo",
-          isActive: true,
-          createdBy: req.user.id
-        },
-        {
-          name: "Netflix Gift Card",
-          description: "$30 Netflix gift card for movies and shows.",
-          category: "Gift Cards",
-          points: 250,
-          imageUrl: "https://images.unsplash.com/photo-1522869635100-9f4c5e86aa37?w=500&h=300&fit=crop",
-          supplier: "tillo",
-          isActive: true,
-          createdBy: req.user.id
-        },
-        {
-          name: "Uber Eats Gift Card",
-          description: "$35 Uber Eats credit for meals delivered to your door.",
-          category: "Gift Cards",
-          points: 280,
-          imageUrl: "https://images.unsplash.com/photo-1593504049359-74330189a345?w=500&h=300&fit=crop",
-          supplier: "tillo",
-          isActive: true,
-          createdBy: req.user.id
-        },
-        {
-          name: "Apple App Store Gift Card",
-          description: "$25 Apple App Store credit for apps, games and entertainment.",
-          category: "Gift Cards",
-          points: 200,
-          imageUrl: "https://images.unsplash.com/photo-1585184394271-4c0a47dc59c9?w=500&h=300&fit=crop",
-          supplier: "tillo",
-          isActive: true,
-          createdBy: req.user.id
-        },
-        {
-          name: "Google Play Gift Card",
-          description: "$25 Google Play credit for apps, games, books, and more.",
-          category: "Gift Cards",
-          points: 200,
-          imageUrl: "https://images.unsplash.com/photo-1611944212129-29977ae1398c?w=500&h=300&fit=crop",
-          supplier: "tillo",
-          isActive: true,
-          createdBy: req.user.id
-        },
-        {
-          name: "DoorDash Gift Card",
-          description: "$30 DoorDash credit for food delivery from your favorite restaurants.",
-          category: "Gift Cards",
-          points: 240,
-          imageUrl: "https://images.unsplash.com/photo-1582060371588-5d30bf398aa1?w=500&h=300&fit=crop",
-          supplier: "tillo",
-          isActive: true,
-          createdBy: req.user.id
-        },
-        {
-          name: "Spotify Premium Gift Card",
-          description: "3-month subscription to Spotify Premium.",
-          category: "Gift Cards",
-          points: 300,
-          imageUrl: "https://images.unsplash.com/photo-1614680376573-df3480f0c6ff?w=500&h=300&fit=crop",
-          supplier: "tillo",
-          isActive: true,
-          createdBy: req.user.id
-        },
-        {
-          name: "Target Gift Card",
-          description: "$50 Target gift card for shopping essentials and more.",
-          category: "Gift Cards",
-          points: 400,
-          imageUrl: "https://images.unsplash.com/photo-1580828343064-fde4fc206bc6?w=500&h=300&fit=crop",
-          supplier: "tillo",
-          isActive: true,
-          createdBy: req.user.id
-        },
-        {
-          name: "Walmart Gift Card",
-          description: "$50 Walmart gift card for everyday essentials.",
-          category: "Gift Cards",
-          points: 400,
-          imageUrl: "https://images.unsplash.com/photo-1601524909162-ae8725290836?w=500&h=300&fit=crop",
-          supplier: "tillo",
-          isActive: true,
-          createdBy: req.user.id
-        },
-        {
-          name: "Best Buy Gift Card",
-          description: "$100 Best Buy gift card for electronics and appliances.",
-          category: "Gift Cards",
-          points: 800,
-          imageUrl: "https://images.unsplash.com/photo-1593784991095-a205069470b6?w=500&h=300&fit=crop",
-          supplier: "tillo",
-          isActive: true,
-          createdBy: req.user.id
-        },
-        {
-          name: "Airbnb Gift Card",
-          description: "$100 Airbnb credit for your next getaway.",
-          category: "Gift Cards",
-          points: 800,
-          imageUrl: "https://images.unsplash.com/photo-1564501049412-61c2a3083791?w=500&h=300&fit=crop",
-          supplier: "tillo",
-          isActive: true,
-          createdBy: req.user.id
-        },
-        {
-          name: "Steam Gift Card",
-          description: "$50 Steam credit for PC games and software.",
-          category: "Gift Cards",
-          points: 400,
-          imageUrl: "https://images.unsplash.com/photo-1609092472326-41329e320fbc?w=500&h=300&fit=crop",
-          supplier: "tillo",
-          isActive: true,
-          createdBy: req.user.id
-        },
-        {
-          name: "Xbox Gift Card",
-          description: "$60 Xbox gift card for games and digital content.",
-          category: "Gift Cards",
-          points: 480,
-          imageUrl: "https://images.unsplash.com/photo-1621259182978-fbf93132d53d?w=500&h=300&fit=crop",
-          supplier: "tillo",
-          isActive: true,
-          createdBy: req.user.id
-        },
-        {
-          name: "PlayStation Store Gift Card",
-          description: "$60 PlayStation Store credit for games and add-ons.",
-          category: "Gift Cards",
-          points: 480,
-          imageUrl: "https://images.unsplash.com/photo-1607853202273-797f1c22a38e?w=500&h=300&fit=crop",
-          supplier: "tillo",
-          isActive: true,
-          createdBy: req.user.id
-        },
-        {
-          name: "Home Depot Gift Card",
-          description: "$75 Home Depot gift card for home improvement projects.",
-          category: "Gift Cards",
-          points: 600,
-          imageUrl: "https://images.unsplash.com/photo-1578496479531-32e296d5c6e1?w=500&h=300&fit=crop",
-          supplier: "tillo",
-          isActive: true,
-          createdBy: req.user.id
-        },
-        {
-          name: "Lowe's Gift Card",
-          description: "$75 Lowe's gift card for home and garden supplies.",
-          category: "Gift Cards",
-          points: 600,
-          imageUrl: "https://images.unsplash.com/photo-1516822669470-73637e892be3?w=500&h=300&fit=crop",
-          supplier: "tillo",
-          isActive: true,
-          createdBy: req.user.id
-        },
-        {
-          name: "Sephora Gift Card",
-          description: "$50 Sephora gift card for beauty and skincare products.",
-          category: "Gift Cards",
-          points: 400,
-          imageUrl: "https://images.unsplash.com/photo-1576426863848-c21f53c60b19?w=500&h=300&fit=crop",
-          supplier: "tillo",
-          isActive: true,
-          createdBy: req.user.id
-        },
-        {
-          name: "Grubhub Gift Card",
-          description: "$40 Grubhub credit for food delivery.",
-          category: "Gift Cards",
-          points: 320,
-          imageUrl: "https://images.unsplash.com/photo-1555992336-fb0d29498b13?w=500&h=300&fit=crop",
-          supplier: "tillo",
-          isActive: true,
-          createdBy: req.user.id
-        },
-        {
-          name: "REI Gift Card",
-          description: "$100 REI gift card for outdoor gear and apparel.",
-          category: "Gift Cards",
-          points: 800,
-          imageUrl: "https://images.unsplash.com/photo-1539183204366-63a0589187ab?w=500&h=300&fit=crop",
-          supplier: "tillo",
-          isActive: true,
-          createdBy: req.user.id
-        },
-        {
-          name: "Disney+ Subscription",
-          description: "6-month subscription to Disney+ streaming service.",
-          category: "Gift Cards",
-          points: 450,
-          imageUrl: "https://images.unsplash.com/photo-1604913571179-f9642e6b43f8?w=500&h=300&fit=crop",
-          supplier: "tillo",
-          isActive: true,
-          createdBy: req.user.id
-        },
-        {
-          name: "Hulu Subscription",
-          description: "6-month subscription to Hulu streaming service.",
-          category: "Gift Cards",
-          points: 420,
-          imageUrl: "https://images.unsplash.com/photo-1580543687419-070d3bd4858c?w=500&h=300&fit=crop",
-          supplier: "tillo",
-          isActive: true,
-          createdBy: req.user.id
-        },
-        {
-          name: "HBO Max Subscription",
-          description: "3-month subscription to HBO Max streaming service.",
-          category: "Gift Cards",
-          points: 450,
-          imageUrl: "https://images.unsplash.com/photo-1520342868574-5fa3804e551c?w=500&h=300&fit=crop",
-          supplier: "tillo",
-          isActive: true,
-          createdBy: req.user.id
-        },
-        {
-          name: "Whole Foods Gift Card",
-          description: "$50 Whole Foods gift card for grocery shopping.",
-          category: "Gift Cards",
-          points: 400,
-          imageUrl: "https://images.unsplash.com/photo-1534723452862-4c874018d66d?w=500&h=300&fit=crop",
-          supplier: "tillo",
-          isActive: true,
-          createdBy: req.user.id
-        },
-        {
-          name: "Audible Subscription",
-          description: "3-month subscription to Audible for audiobooks.",
-          category: "Gift Cards",
-          points: 350,
-          imageUrl: "https://images.unsplash.com/photo-1593784991095-a205069470b6?w=500&h=300&fit=crop",
-          supplier: "tillo",
-          isActive: true,
-          createdBy: req.user.id
-        }
-      ];
-
-      // Electronics Category - 25 products
-      const electronicsProducts = [
-        {
-          name: "Apple Airpods Pro",
-          description: "Latest model with noise cancellation technology.",
-          category: "Electronics",
-          points: 650,
-          imageUrl: "https://images.unsplash.com/photo-1607083206968-13611e3d76db?w=500&h=300&fit=crop",
-          supplier: "carlton",
-          isActive: true,
-          createdBy: req.user.id
-        },
-        {
-          name: "Bluetooth Speaker",
-          description: "Portable high-quality Bluetooth speaker.",
-          category: "Electronics",
-          points: 300,
-          imageUrl: "https://images.unsplash.com/photo-1545454675-3531b543be5d?w=500&h=300&fit=crop",
-          supplier: "carlton",
-          isActive: true,
-          createdBy: req.user.id
-        },
-        {
-          name: "Smart Watch",
-          description: "Fitness and health tracking smart watch.",
-          category: "Electronics",
-          points: 500,
-          imageUrl: "https://images.unsplash.com/photo-1546868871-7041f2a55e12?w=500&h=300&fit=crop",
-          supplier: "carlton",
-          isActive: true,
-          createdBy: req.user.id
-        },
-        {
-          name: "Wireless Charger",
-          description: "Fast wireless charging pad for compatible devices.",
-          category: "Electronics",
-          points: 180,
-          imageUrl: "https://images.unsplash.com/photo-1603539444875-76e7684265f6?w=500&h=300&fit=crop",
-          supplier: "carlton",
-          isActive: true,
-          createdBy: req.user.id
-        },
-        {
-          name: "Noise-Cancelling Headphones",
-          description: "Premium over-ear headphones with active noise cancellation.",
-          category: "Electronics",
-          points: 700,
-          imageUrl: "https://images.unsplash.com/photo-1505740420928-5e560c06d30e?w=500&h=300&fit=crop",
-          supplier: "carlton",
-          isActive: true,
-          createdBy: req.user.id
-        },
-        {
-          name: "Smart Home Speaker",
-          description: "Voice-controlled smart speaker with virtual assistant.",
-          category: "Electronics",
-          points: 350,
-          imageUrl: "https://images.unsplash.com/photo-1549482199-bc1ca6f58502?w=500&h=300&fit=crop",
-          supplier: "carlton",
-          isActive: true,
-          createdBy: req.user.id
-        },
-        {
-          name: "Tablet Stand",
-          description: "Adjustable stand for tablets and e-readers.",
-          category: "Electronics",
-          points: 120,
-          imageUrl: "https://images.unsplash.com/photo-1544244015-0df4b3ffc6b0?w=500&h=300&fit=crop",
-          supplier: "carlton",
-          isActive: true,
-          createdBy: req.user.id
-        },
-        {
-          name: "Portable Power Bank",
-          description: "20,000mAh power bank for charging devices on the go.",
-          category: "Electronics",
-          points: 250,
-          imageUrl: "https://images.unsplash.com/photo-1587047163886-e71b96567eb9?w=500&h=300&fit=crop",
-          supplier: "carlton",
-          isActive: true,
-          createdBy: req.user.id
-        },
-        {
-          name: "Wireless Earbuds",
-          description: "Compact wireless earbuds with charging case.",
-          category: "Electronics",
-          points: 350,
-          imageUrl: "https://images.unsplash.com/photo-1623515651673-28033bd10d13?w=500&h=300&fit=crop",
-          supplier: "carlton",
-          isActive: true,
-          createdBy: req.user.id
-        },
-        {
-          name: "Smart Bulb Kit",
-          description: "Set of 4 smart LED bulbs with app control.",
-          category: "Electronics",
-          points: 280,
-          imageUrl: "https://images.unsplash.com/photo-1569073120512-05362a6b92e4?w=500&h=300&fit=crop",
-          supplier: "carlton",
-          isActive: true,
-          createdBy: req.user.id
-        },
-        {
-          name: "Digital Photo Frame",
-          description: "10-inch digital photo frame with cloud connectivity.",
-          category: "Electronics",
-          points: 400,
-          imageUrl: "https://images.unsplash.com/photo-1540885762261-a2ca01f290f9?w=500&h=300&fit=crop",
-          supplier: "carlton",
-          isActive: true,
-          createdBy: req.user.id
-        },
-        {
-          name: "Smartphone Gimbal",
-          description: "3-axis stabilizer for smartphone videography.",
-          category: "Electronics",
-          points: 450,
-          imageUrl: "https://images.unsplash.com/photo-1595781572981-d63151b232ed?w=500&h=300&fit=crop",
-          supplier: "carlton",
-          isActive: true,
-          createdBy: req.user.id
-        },
-        {
-          name: "Smart Scale",
-          description: "Digital bathroom scale with health metrics and app integration.",
-          category: "Electronics",
-          points: 320,
-          imageUrl: "https://images.unsplash.com/photo-1518611012118-696072aa579a?w=500&h=300&fit=crop",
-          supplier: "carlton",
-          isActive: true,
-          createdBy: req.user.id
-        },
-        {
-          name: "Portable Bluetooth Keyboard",
-          description: "Foldable Bluetooth keyboard for tablets and smartphones.",
-          category: "Electronics",
-          points: 200,
-          imageUrl: "https://images.unsplash.com/photo-1516317518460-4a16985740e6?w=500&h=300&fit=crop",
-          supplier: "carlton",
-          isActive: true,
-          createdBy: req.user.id
-        },
-        {
-          name: "Video Doorbell",
-          description: "Smart doorbell with camera and two-way audio.",
-          category: "Electronics",
-          points: 550,
-          imageUrl: "https://images.unsplash.com/photo-1558002038-1055e2fc65af?w=500&h=300&fit=crop",
-          supplier: "carlton",
-          isActive: true,
-          createdBy: req.user.id
-        },
-        {
-          name: "Smart Thermostat",
-          description: "Energy-saving smart thermostat with remote control.",
-          category: "Electronics",
-          points: 480,
-          imageUrl: "https://images.unsplash.com/photo-1567769541735-d43de3326c00?w=500&h=300&fit=crop",
-          supplier: "carlton",
-          isActive: true,
-          createdBy: req.user.id
-        },
-        {
-          name: "Wireless Mouse",
-          description: "Ergonomic wireless mouse with long battery life.",
-          category: "Electronics",
-          points: 150,
-          imageUrl: "https://images.unsplash.com/photo-1605773527852-c546a8584ea3?w=500&h=300&fit=crop",
-          supplier: "carlton",
-          isActive: true,
-          createdBy: req.user.id
-        },
-        {
-          name: "USB-C Hub",
-          description: "7-in-1 USB-C hub adapter with multiple ports.",
-          category: "Electronics",
-          points: 220,
-          imageUrl: "https://images.unsplash.com/photo-1634328783781-b542bce0b3a6?w=500&h=300&fit=crop",
-          supplier: "carlton",
-          isActive: true,
-          createdBy: req.user.id
-        },
-        {
-          name: "Portable Bluetooth Printer",
-          description: "Compact photo printer for smartphones and tablets.",
-          category: "Electronics",
-          points: 380,
-          imageUrl: "https://images.unsplash.com/photo-1612815154858-60aa4c59eaa6?w=500&h=300&fit=crop",
-          supplier: "carlton",
-          isActive: true,
-          createdBy: req.user.id
-        },
-        {
-          name: "Streaming Media Player",
-          description: "4K streaming device for smart TVs.",
-          category: "Electronics",
-          points: 320,
-          imageUrl: "https://images.unsplash.com/photo-1593359677879-a4bb92f829d1?w=500&h=300&fit=crop",
-          supplier: "carlton",
-          isActive: true,
-          createdBy: req.user.id
-        },
-        {
-          name: "Wireless Charging Stand",
-          description: "Vertical wireless charging stand for smartphones.",
-          category: "Electronics",
-          points: 220,
-          imageUrl: "https://images.unsplash.com/photo-1633060284626-89f955be6f0a?w=500&h=300&fit=crop",
-          supplier: "carlton",
-          isActive: true,
-          createdBy: req.user.id
-        },
-        {
-          name: "Gaming Controller",
-          description: "Bluetooth gaming controller compatible with PC and mobile.",
-          category: "Electronics",
-          points: 280,
-          imageUrl: "https://images.unsplash.com/photo-1580327344181-c1163234e5a0?w=500&h=300&fit=crop",
-          supplier: "carlton",
-          isActive: true,
-          createdBy: req.user.id
-        },
-        {
-          name: "Bluetooth Tracker Tags",
-          description: "Set of 4 Bluetooth trackers for keys, wallets, and more.",
-          category: "Electronics",
-          points: 190,
-          imageUrl: "https://images.unsplash.com/photo-1513116476489-7635e79feb27?w=500&h=300&fit=crop",
-          supplier: "carlton",
-          isActive: true,
-          createdBy: req.user.id
-        },
-        {
-          name: "Mini Drone",
-          description: "Compact drone with HD camera and app control.",
-          category: "Electronics",
-          points: 700,
-          imageUrl: "https://images.unsplash.com/photo-1507582020474-9a35b7d455d9?w=500&h=300&fit=crop",
-          supplier: "carlton",
-          isActive: true,
-          createdBy: req.user.id
-        },
-        {
-          name: "Polaroid Camera",
-          description: "Instant camera with built-in printer for immediate photos.",
-          category: "Electronics",
-          points: 650,
-          imageUrl: "https://images.unsplash.com/photo-1526170375885-4d8ecf77b99f?w=500&h=300&fit=crop",
-          supplier: "carlton",
-          isActive: true,
-          createdBy: req.user.id
-        }
-      ];
-
-      // Experiences Category - 25 products
-      const experiencesProducts = [
-        {
-          name: "Wellness Retreat Day",
-          description: "Full day pass at luxury spa including treatments.",
-          category: "Experiences",
-          points: 550,
-          imageUrl: "https://images.unsplash.com/photo-1542282088-72c9c27ed0cd?w=500&h=300&fit=crop",
-          supplier: "carlton",
-          isActive: true,
-          createdBy: req.user.id
-        },
-        {
-          name: "Movie Tickets",
-          description: "Two premium movie tickets for the theater of your choice.",
-          category: "Experiences",
-          points: 150,
-          imageUrl: "https://images.unsplash.com/photo-1489599849927-2ee91cede3ba?w=500&h=300&fit=crop",
-          supplier: "tillo",
-          isActive: true,
-          createdBy: req.user.id
-        },
-        {
-          name: "Wine Tasting Tour",
-          description: "Guided tour of a local winery with tastings for two.",
-          category: "Experiences",
-          points: 400,
-          imageUrl: "https://images.unsplash.com/photo-1506377247377-2a5b3b417ebb?w=500&h=300&fit=crop",
-          supplier: "carlton",
-          isActive: true,
-          createdBy: req.user.id
-        },
-        {
-          name: "Cooking Class",
-          description: "Interactive cooking class with professional chef.",
-          category: "Experiences",
-          points: 350,
-          imageUrl: "https://images.unsplash.com/photo-1507048331197-7d4ac70811cf?w=500&h=300&fit=crop",
-          supplier: "carlton",
-          isActive: true,
-          createdBy: req.user.id
-        },
-        {
-          name: "Concert Tickets",
-          description: "Two tickets to a live music performance of your choice.",
-          category: "Experiences",
-          points: 500,
-          imageUrl: "https://images.unsplash.com/photo-1501612780327-45045538702b?w=500&h=300&fit=crop",
-          supplier: "tillo",
-          isActive: true,
-          createdBy: req.user.id
-        },
-        {
-          name: "Museum Annual Pass",
-          description: "12-month membership to local art and science museums.",
-          category: "Experiences",
-          points: 600,
-          imageUrl: "https://images.unsplash.com/photo-1503632235181-2618281d021e?w=500&h=300&fit=crop",
-          supplier: "carlton",
-          isActive: true,
-          createdBy: req.user.id
-        },
-        {
-          name: "Hot Air Balloon Ride",
-          description: "Scenic hot air balloon experience for one person.",
-          category: "Experiences",
-          points: 800,
-          imageUrl: "https://images.unsplash.com/photo-1507608869274-d3177c8bb4c7?w=500&h=300&fit=crop",
-          supplier: "carlton",
-          isActive: true,
-          createdBy: req.user.id
-        },
-        {
-          name: "Pottery Workshop",
-          description: "Hands-on pottery class with materials included.",
-          category: "Experiences",
-          points: 300,
-          imageUrl: "https://images.unsplash.com/photo-1565122640447-3128631baa36?w=500&h=300&fit=crop",
-          supplier: "carlton",
-          isActive: true,
-          createdBy: req.user.id
-        },
-        {
-          name: "Kayaking Adventure",
-          description: "Guided kayaking tour for two on scenic waterways.",
-          category: "Experiences",
-          points: 450,
-          imageUrl: "https://images.unsplash.com/photo-1511098217401-2291d3b7cebd?w=500&h=300&fit=crop",
-          supplier: "carlton",
-          isActive: true,
-          createdBy: req.user.id
-        },
-        {
-          name: "Theme Park Day Pass",
-          description: "Two tickets to a popular theme park for a full day of fun.",
-          category: "Experiences",
-          points: 700,
-          imageUrl: "https://images.unsplash.com/photo-1543313661-988f8be8809a?w=500&h=300&fit=crop",
-          supplier: "tillo",
-          isActive: true,
-          createdBy: req.user.id
-        },
-        {
-          name: "Escape Room Challenge",
-          description: "Admission for 4 to an immersive escape room game.",
-          category: "Experiences",
-          points: 380,
-          imageUrl: "https://images.unsplash.com/photo-1543101516-5bcc9614f918?w=500&h=300&fit=crop",
-          supplier: "tillo",
-          isActive: true,
-          createdBy: req.user.id
-        },
-        {
-          name: "Zip-lining Experience",
-          description: "Exhilarating zip-line course through scenic landscapes.",
-          category: "Experiences",
-          points: 550,
-          imageUrl: "https://images.unsplash.com/photo-1544230980-8f19ebdb9ea1?w=500&h=300&fit=crop",
-          supplier: "carlton",
-          isActive: true,
-          createdBy: req.user.id
-        },
-        {
-          name: "Golf Lesson Package",
-          description: "Series of 3 golf lessons with a PGA professional.",
-          category: "Experiences",
-          points: 650,
-          imageUrl: "https://images.unsplash.com/photo-1587174486073-ae5e5cff23aa?w=500&h=300&fit=crop",
-          supplier: "carlton",
-          isActive: true,
-          createdBy: req.user.id
-        },
-        {
-          name: "Skydiving Simulation",
-          description: "Indoor skydiving experience with professional instruction.",
-          category: "Experiences",
-          points: 480,
-          imageUrl: "https://images.unsplash.com/photo-1511169355326-be606c6e1da7?w=500&h=300&fit=crop",
-          supplier: "carlton",
-          isActive: true,
-          createdBy: req.user.id
-        },
-        {
-          name: "Comedy Club Tickets",
-          description: "Two tickets to a live stand-up comedy show.",
-          category: "Experiences",
-          points: 250,
-          imageUrl: "https://images.unsplash.com/photo-1527224857830-43a7acc85260?w=500&h=300&fit=crop",
-          supplier: "tillo",
-          isActive: true,
-          createdBy: req.user.id
-        },
-        {
-          name: "Brewery Tour & Tasting",
-          description: "Behind-the-scenes tour with beer tasting flight for two.",
-          category: "Experiences",
-          points: 300,
-          imageUrl: "https://images.unsplash.com/photo-1559526324-593bc073d938?w=500&h=300&fit=crop",
-          supplier: "carlton",
-          isActive: true,
-          createdBy: req.user.id
-        },
-        {
-          name: "Rock Climbing Session",
-          description: "Indoor rock climbing experience with gear and instruction.",
-          category: "Experiences",
-          points: 280,
-          imageUrl: "https://images.unsplash.com/photo-1522163182402-834f871fd851?w=500&h=300&fit=crop",
-          supplier: "carlton",
-          isActive: true,
-          createdBy: req.user.id
-        },
-        {
-          name: "Helicopter City Tour",
-          description: "15-minute helicopter sightseeing tour for one person.",
-          category: "Experiences",
-          points: 1200,
-          imageUrl: "https://images.unsplash.com/photo-1583991111178-7b042e3077f6?w=500&h=300&fit=crop",
-          supplier: "carlton",
-          isActive: true,
-          createdBy: req.user.id
-        },
-        {
-          name: "Horseback Riding Lesson",
-          description: "Beginner horseback riding lesson with professional instruction.",
-          category: "Experiences",
-          points: 350,
-          imageUrl: "https://images.unsplash.com/photo-1511195448591-062cec834bc2?w=500&h=300&fit=crop",
-          supplier: "carlton",
-          isActive: true,
-          createdBy: req.user.id
-        },
-        {
-          name: "Painting & Wine Workshop",
-          description: "Guided painting session with complimentary wine.",
-          category: "Experiences",
-          points: 320,
-          imageUrl: "https://images.unsplash.com/photo-1547333590-47fae5f58d21?w=500&h=300&fit=crop",
-          supplier: "carlton",
-          isActive: true,
-          createdBy: req.user.id
-        },
-        {
-          name: "Dance Class Package",
-          description: "4-class package for ballroom or Latin dance lessons.",
-          category: "Experiences",
-          points: 400,
-          imageUrl: "https://images.unsplash.com/photo-1547048615-da56eb92d444?w=500&h=300&fit=crop",
-          supplier: "carlton",
-          isActive: true,
-          createdBy: req.user.id
-        },
-        {
-          name: "Sushi Making Workshop",
-          description: "Learn to make sushi rolls with a professional chef.",
-          category: "Experiences",
-          points: 370,
-          imageUrl: "https://images.unsplash.com/photo-1583623025817-d180a2fe075e?w=500&h=300&fit=crop",
-          supplier: "carlton",
-          isActive: true,
-          createdBy: req.user.id
-        },
-        {
-          name: "Axe Throwing Session",
-          description: "1-hour axe throwing session with instruction for two people.",
-          category: "Experiences",
-          points: 280,
-          imageUrl: "https://images.unsplash.com/photo-1574103188526-4faae477d34e?w=500&h=300&fit=crop",
-          supplier: "carlton",
-          isActive: true,
-          createdBy: req.user.id
-        },
-        {
-          name: "Star Gazing Tour",
-          description: "Guided nighttime astronomy experience with telescopes.",
-          category: "Experiences",
-          points: 420,
-          imageUrl: "https://images.unsplash.com/photo-1509773896068-7fd415d91e2e?w=500&h=300&fit=crop",
-          supplier: "carlton",
-          isActive: true,
-          createdBy: req.user.id
-        },
-        {
-          name: "Luxury Boat Cruise",
-          description: "2-hour sunset cruise on a luxury yacht for two.",
-          category: "Experiences",
-          points: 900,
-          imageUrl: "https://images.unsplash.com/photo-1544551763-46a013bb70d5?w=500&h=300&fit=crop",
-          supplier: "carlton",
-          isActive: true,
-          createdBy: req.user.id
-        }
-      ];
-
-      // Wellness Category - 25 products
-      const wellnessProducts = [
-        {
-          name: "Yoga Class Package",
-          description: "10-class package at a premium yoga studio.",
-          category: "Wellness",
-          points: 350,
-          imageUrl: "https://images.unsplash.com/photo-1588286840104-8957b019727f?w=500&h=300&fit=crop",
-          supplier: "carlton",
-          isActive: true,
-          createdBy: req.user.id
-        },
-        {
-          name: "Monthly Gym Membership",
-          description: "30-day access to a premium fitness club.",
-          category: "Wellness",
-          points: 500,
-          imageUrl: "https://images.unsplash.com/photo-1534438327276-14e5300c3a48?w=500&h=300&fit=crop",
-          supplier: "carlton",
-          isActive: true,
-          createdBy: req.user.id
-        },
-        {
-          name: "Premium Massage Chair Session",
-          description: "1-hour session in a luxury massage chair.",
-          category: "Wellness",
-          points: 250,
-          imageUrl: "https://images.unsplash.com/photo-1600334129128-685c5582fd35?w=500&h=300&fit=crop",
-          supplier: "carlton",
-          isActive: true,
-          createdBy: req.user.id
-        },
-        {
-          name: "Meditation Course",
-          description: "8-week guided meditation program with certified instructor.",
-          category: "Wellness",
-          points: 400,
-          imageUrl: "https://images.unsplash.com/photo-1536623975707-c4b3b2af565d?w=500&h=300&fit=crop",
-          supplier: "carlton",
-          isActive: true,
-          createdBy: req.user.id
-        },
-        {
-          name: "Aromatherapy Gift Set",
-          description: "Essential oil diffuser with 6 premium essential oils.",
-          category: "Wellness",
-          points: 320,
-          imageUrl: "https://images.unsplash.com/photo-1608571423902-eed4a5ad8108?w=500&h=300&fit=crop",
-          supplier: "carlton",
-          isActive: true,
-          createdBy: req.user.id
-        },
-        {
-          name: "Weighted Blanket",
-          description: "15lb therapeutic weighted blanket for better sleep.",
-          category: "Wellness",
-          points: 380,
-          imageUrl: "https://images.unsplash.com/photo-1631756964162-25c8c07579b1?w=500&h=300&fit=crop",
-          supplier: "carlton",
-          isActive: true,
-          createdBy: req.user.id
-        },
-        {
-          name: "Acupuncture Session",
-          description: "Traditional acupuncture therapy with certified practitioner.",
-          category: "Wellness",
-          points: 450,
-          imageUrl: "https://images.unsplash.com/photo-1545205597-3d9d02c29597?w=500&h=300&fit=crop",
-          supplier: "carlton",
-          isActive: true,
-          createdBy: req.user.id
-        },
-        {
-          name: "Home Fitness Equipment",
-          description: "Resistance band set with workout guide.",
-          category: "Wellness",
-          points: 220,
-          imageUrl: "https://images.unsplash.com/photo-1598550593506-b035cba3ba0e?w=500&h=300&fit=crop",
-          supplier: "carlton",
-          isActive: true,
-          createdBy: req.user.id
-        },
-        {
-          name: "Nutritional Counseling",
-          description: "Personalized nutrition consultation with registered dietitian.",
-          category: "Wellness",
-          points: 600,
-          imageUrl: "https://images.unsplash.com/photo-1505576633757-0ac1084f63cd?w=500&h=300&fit=crop",
-          supplier: "carlton",
-          isActive: true,
-          createdBy: req.user.id
-        },
-        {
-          name: "Sleep Therapy Light",
-          description: "Light therapy lamp for improved sleep and mood.",
-          category: "Wellness",
-          points: 300,
-          imageUrl: "https://images.unsplash.com/photo-1542728928-1413d1894ed1?w=500&h=300&fit=crop",
-          supplier: "carlton",
-          isActive: true,
-          createdBy: req.user.id
-        },
-        {
-          name: "Yoga Mat & Props Set",
-          description: "Premium yoga mat with blocks, strap, and towel.",
-          category: "Wellness",
-          points: 280,
-          imageUrl: "https://images.unsplash.com/photo-1576095910607-644cd66e5c65?w=500&h=300&fit=crop",
-          supplier: "carlton",
-          isActive: true,
-          createdBy: req.user.id
-        },
-        {
-          name: "Mindfulness Journal",
-          description: "Guided journal for daily mindfulness practice.",
-          category: "Wellness",
-          points: 150,
-          imageUrl: "https://images.unsplash.com/photo-1615310748514-99796d46e94e?w=500&h=300&fit=crop",
-          supplier: "carlton",
-          isActive: true,
-          createdBy: req.user.id
-        },
-        {
-          name: "Himalayan Salt Lamp",
-          description: "Natural salt crystal lamp for air purification.",
-          category: "Wellness",
-          points: 200,
-          imageUrl: "https://images.unsplash.com/photo-1539207554081-7214fbd6e282?w=500&h=300&fit=crop",
-          supplier: "carlton",
-          isActive: true,
-          createdBy: req.user.id
-        },
-        {
-          name: "Foot Massager",
-          description: "Electric foot massager with heat therapy.",
-          category: "Wellness",
-          points: 420,
-          imageUrl: "https://images.unsplash.com/photo-1595238242018-22219945cf66?w=500&h=300&fit=crop",
-          supplier: "carlton",
-          isActive: true,
-          createdBy: req.user.id
-        },
-        {
-          name: "Water Purification System",
-          description: "Countertop water filter for clean drinking water.",
-          category: "Wellness",
-          points: 350,
-          imageUrl: "https://images.unsplash.com/photo-1546483667-f62d66b96636?w=500&h=300&fit=crop",
-          supplier: "carlton",
-          isActive: true,
-          createdBy: req.user.id
-        },
-        {
-          name: "Organic Tea Collection",
-          description: "Assortment of premium organic herbal teas.",
-          category: "Wellness",
-          points: 180,
-          imageUrl: "https://images.unsplash.com/photo-1563911892437-1feda0179e41?w=500&h=300&fit=crop",
-          supplier: "carlton",
-          isActive: true,
-          createdBy: req.user.id
-        },
-        {
-          name: "Personal Air Purifier",
-          description: "HEPA air purifier for home or office.",
-          category: "Wellness",
-          points: 480,
-          imageUrl: "https://images.unsplash.com/photo-1598803783347-dada77361e66?w=500&h=300&fit=crop",
-          supplier: "carlton",
-          isActive: true,
-          createdBy: req.user.id
-        },
-        {
-          name: "Fitness Tracker Watch",
-          description: "Smart fitness tracker with heart rate monitoring.",
-          category: "Wellness",
-          points: 500,
-          imageUrl: "https://images.unsplash.com/photo-1508685096489-7aacd43bd3b1?w=500&h=300&fit=crop",
-          supplier: "carlton",
-          isActive: true,
-          createdBy: req.user.id
-        },
-        {
-          name: "Posture Corrector",
-          description: "Adjustable brace for improved posture and back support.",
-          category: "Wellness",
-          points: 140,
-          imageUrl: "https://images.unsplash.com/photo-1537344836915-25a58b04e69c?w=500&h=300&fit=crop",
-          supplier: "carlton",
-          isActive: true,
-          createdBy: req.user.id
-        },
-        {
-          name: "Luxury Bath Set",
-          description: "Premium bath bombs, salts, and oils for relaxation.",
-          category: "Wellness",
-          points: 230,
-          imageUrl: "https://images.unsplash.com/photo-1532771522233-9079b9616c44?w=500&h=300&fit=crop",
-          supplier: "carlton",
-          isActive: true,
-          createdBy: req.user.id
-        },
-        {
-          name: "Sleep Sound Machine",
-          description: "White noise machine with natural sounds for better sleep.",
-          category: "Wellness",
-          points: 250,
-          imageUrl: "https://images.unsplash.com/photo-1631703412785-e9754dea55c6?w=500&h=300&fit=crop",
-          supplier: "carlton",
-          isActive: true,
-          createdBy: req.user.id
-        },
-        {
-          name: "Indoor Plant Collection",
-          description: "Set of 3 air-purifying houseplants with decorative pots.",
-          category: "Wellness",
-          points: 280,
-          imageUrl: "https://images.unsplash.com/photo-1545165375-7c5f3a1a2c83?w=500&h=300&fit=crop",
-          supplier: "carlton",
-          isActive: true,
-          createdBy: req.user.id
-        },
-        {
-          name: "Foam Roller Set",
-          description: "Deep tissue massage foam roller and balls for recovery.",
-          category: "Wellness",
-          points: 210,
-          imageUrl: "https://images.unsplash.com/photo-1600881333168-2ef49b341f30?w=500&h=300&fit=crop",
-          supplier: "carlton",
-          isActive: true,
-          createdBy: req.user.id
-        },
-        {
-          name: "Cold Therapy System",
-          description: "Targeted cold therapy for muscle recovery and pain relief.",
-          category: "Wellness",
-          points: 370,
-          imageUrl: "https://images.unsplash.com/photo-1605296867424-35c82a8b1da1?w=500&h=300&fit=crop",
-          supplier: "carlton",
-          isActive: true,
-          createdBy: req.user.id
-        },
-        {
-          name: "Luxury Bathrobe",
-          description: "Premium Turkish cotton spa robe.",
-          category: "Wellness",
-          points: 320,
-          imageUrl: "https://images.unsplash.com/photo-1614255976202-43b92dfb7d67?w=500&h=300&fit=crop",
-          supplier: "carlton",
-          isActive: true,
-          createdBy: req.user.id
-        }
-      ];
-
-      // Combine all products into one array
-      const allProducts = [
-        ...giftCardProducts,
-        ...electronicsProducts,
-        ...experiencesProducts,
-        ...wellnessProducts
-      ];
-
-      for (const product of allProducts) {
-        await db.insert(products).values(product);
-      }
-
-      console.log("Demo products seeded successfully");
-      res.json({ message: "Demo products seeded successfully" });
-    } catch (error) {
-      console.error("Error seeding initial data:", error);
-      res.status(500).json({ message: "Failed to seed demo products" });
-    }
-  });
-
-  // Channel creation endpoint
-  app.post("/api/channels", verifyToken, async (req: AuthenticatedRequest, res) => {
-    try {
-      if (!req.user) {
-        return res.status(401).json({ message: "Unauthorized" });
-      }
-
-      const {
-        name,
-        description,
-        channelType,
-        maxMembers,
-        isPrivate,
-        requiresApproval,
-        allowedDepartments = [],
-        allowedLocations = [],
-        autoAddMembers = false,
-        initialMembers = []
-      } = req.body;
-
-      // Validate required fields
-      if (!name || !channelType) {
-        return res.status(400).json({ message: "Channel name and type are required" });
-      }
-
-      // Determine access level based on privacy settings
-      let accessLevel = "open";
-      if (isPrivate) {
-        accessLevel = "invite_only";
-      } else if (requiresApproval) {
-        accessLevel = "approval_required";
-      } else if (allowedDepartments.length > 0) {
-        accessLevel = "department_only";
-      } else if (allowedLocations.length > 0) {
-        accessLevel = "site_only";
-      }
-
-      // Insert into interestChannels table
-      const [newChannel] = await db.insert(interestChannels).values({
-        name,
-        description,
-        channelType,
-        accessLevel,
-        allowedDepartments: allowedDepartments.length > 0 ? allowedDepartments : null,
-        allowedSites: allowedLocations.length > 0 ? allowedLocations : null,
-        isAutoCreated: false,
-        createdBy: req.user.id,
-        organizationId: req.user.organizationId || 1, // Default to org 1 if not set
-        memberCount: 0
-      }).returning();
-
-      // Add initial members if specified
-      if (initialMembers.length > 0) {
-        const memberInserts = initialMembers.map((userId: number) => ({
-          channelId: newChannel.id,
-          userId,
-          role: 'member'
-        }));
-
-        await db.insert(interestChannelMembers).values(memberInserts);
-
-        // Update member count
-        await db.update(interestChannels)
-          .set({ memberCount: initialMembers.length })
-          .where(eq(interestChannels.id, newChannel.id));
-      }
-
-      // Auto-add members based on departments/locations if enabled
-      if (autoAddMembers && (allowedDepartments.length > 0 || allowedLocations.length > 0)) {
-        let whereConditions = [];
-
-        if (allowedDepartments.length > 0) {
-          whereConditions.push(inArray(users.department, allowedDepartments));
-        }
-
-        if (allowedLocations.length > 0) {
-          whereConditions.push(inArray(users.location, allowedLocations));
-        }
-
-        if (whereConditions.length > 0) {
-          const eligibleUsers = await db.select({ id: users.id })
-            .from(users)
-            .where(or(...whereConditions));
-
-          if (eligibleUsers.length > 0) {
-            const autoMemberInserts = eligibleUsers.map(user => ({
-              channelId: newChannel.id,
-              userId: user.id,
-              role: 'member'
-            }));
-
-            await db.insert(interestChannelMembers)
-              .values(autoMemberInserts)
-              .onConflictDoNothing();
-
-            // Update member count
-            await db.update(interestChannels)
-              .set({ memberCount: eligibleUsers.length })
-              .where(eq(interestChannels.id, newChannel.id));
-          }
-        }
-      }
-
-      res.status(201).json({ 
-        message: "Channel created successfully",
-        channel: newChannel 
-      });
-    } catch (error) {
-      console.error("Error creating channel:", error);
-      res.status(500).json({ message: "Failed to create channel" });
-    }
-  });
-
-  // Get channels trending
-  app.get('/api/channels/trending', verifyToken, async (req: AuthenticatedRequest, res) => {
-    try {
-      // For now, return empty array as we don't have trending logic yet
-      const trendingChannels = await db.select()
-        .from(interestChannels)
-        .where(eq(interestChannels.isActive, true))
-        .orderBy(desc(interestChannels.memberCount))
-        .limit(5);
-
-      res.json(trendingChannels);
-    } catch (error) {
-      console.error('Error fetching trending channels:', error);
-      res.status(500).json({ message: 'Failed to fetch trending channels' });
-    }
-  });
-
-  // Get individual channel by ID
-  app.get('/api/channels/:id', verifyToken, async (req: AuthenticatedRequest, res) => {
-    try {
-      if (!req.user) {
-        return res.status(401).json({ message: "Unauthorized" });
-      }
-
-      const channelId = parseInt(req.params.id);
-      
-      if (isNaN(channelId)) {
-        return res.status(400).json({ message: "Invalid channel ID" });
-      }
-      
-      // Get channel data with explicit field mapping
-      const [channel] = await db.select({
-        id: interestChannels.id,
-        name: interestChannels.name,
-        description: interestChannels.description,
-        channelType: interestChannels.channelType,
-        accessLevel: interestChannels.accessLevel,
-        memberCount: interestChannels.memberCount,
-        isActive: interestChannels.isActive,
-        allowedDepartments: interestChannels.allowedDepartments,
-        allowedSites: interestChannels.allowedSites,
-        createdBy: interestChannels.createdBy,
-        organizationId: interestChannels.organizationId,
-        createdAt: interestChannels.createdAt,
-        coverImageUrl: interestChannels.coverImageUrl
-      })
-        .from(interestChannels)
-        .where(
-          and(
-            eq(interestChannels.id, channelId),
-            eq(interestChannels.isActive, true),
-            eq(interestChannels.organizationId, req.user.organizationId || 1)
-          )
-        );
-
-      if (!channel) {
-        return res.status(404).json({ message: "Channel not found" });
-      }
-
-      console.log('Channel data being returned:', JSON.stringify(channel, null, 2));
-      res.json(channel);
-    } catch (error) {
-      console.error('Error fetching channel:', error);
-      res.status(500).json({ message: 'Failed to fetch channel' });
-    }
-  });
-
-  // Get all channels (public endpoint for channels discovery page)
-  app.get('/api/channels', verifyToken, async (req: AuthenticatedRequest, res) => {
-    try {
-      if (!req.user) {
-        return res.status(401).json({ message: "Unauthorized" });
-      }
-
-      // Get all active channels for the user's organization
-      const channels = await db.select({
-        id: interestChannels.id,
-        name: interestChannels.name,
-        description: interestChannels.description,
-        channelType: interestChannels.channelType,
-        accessLevel: interestChannels.accessLevel,
-        memberCount: interestChannels.memberCount,
-        isActive: interestChannels.isActive,
-        allowedDepartments: interestChannels.allowedDepartments,
-        allowedSites: interestChannels.allowedSites,
-        createdAt: interestChannels.createdAt,
-        createdBy: interestChannels.createdBy,
-        organizationId: interestChannels.organizationId
-      })
-      .from(interestChannels)
-      .where(
-        and(
-          eq(interestChannels.isActive, true),
-          eq(interestChannels.organizationId, req.user.organizationId || 1)
-        )
-      )
-      .orderBy(desc(interestChannels.createdAt));
-
-      res.json(channels);
-    } catch (error) {
-      console.error('Error fetching channels:', error);
-      res.status(500).json({ message: 'Failed to fetch channels' });
-    }
-  });
-
-  // Get user's channel memberships
-  app.get('/api/channels/my-channels', verifyToken, async (req: AuthenticatedRequest, res) => {
-    try {
-      if (!req.user) {
-        return res.status(401).json({ message: "Unauthorized" });
-      }
-
-      // Get channels the user is a member of
-      const userChannels = await db.select({
-        channelId: interestChannelMembers.channelId,
-        role: interestChannelMembers.role,
-        joinedAt: interestChannelMembers.joinedAt,
-        channelName: interestChannels.name,
-        channelType: interestChannels.channelType,
-        memberCount: interestChannels.memberCount
-      })
-      .from(interestChannelMembers)
-      .innerJoin(interestChannels, eq(interestChannelMembers.channelId, interestChannels.id))
-      .where(
-        and(
-          eq(interestChannelMembers.userId, Number(req.user.id) || 0),
-          eq(interestChannels.isActive, true)
-        )
-      )
-      .orderBy(desc(interestChannelMembers.joinedAt));
-
-      res.json(userChannels);
-    } catch (error) {
-      console.error('Error fetching user channels:', error);
-      res.status(500).json({ message: 'Failed to fetch channels' });
-    }
-  });
-
-  // Get channel posts
-  app.get('/api/channels/:id/posts', verifyToken, async (req: AuthenticatedRequest, res) => {
-    try {
-      if (!req.user) {
-        return res.status(401).json({ message: "Unauthorized" });
-      }
-
-      const channelId = parseInt(req.params.id);
-      
-      if (isNaN(channelId)) {
-        return res.status(400).json({ message: "Invalid channel ID" });
-      }
-
-      // Verify channel exists and user has access
-      const [channel] = await db.select()
-        .from(interestChannels)
-        .where(
-          and(
-            eq(interestChannels.id, channelId),
-            eq(interestChannels.isActive, true),
-            eq(interestChannels.organizationId, req.user.organizationId || 1)
-          )
-        );
-
-      if (!channel) {
-        return res.status(404).json({ message: "Channel not found" });
-      }
-
-      // Get posts from interest channel posts table
-      const posts = await db.select({
-        id: interestChannelPosts.id,
-        content: interestChannelPosts.content,
-        userId: sql<number>`${interestChannelPosts}.user_id`,
-        userName: users.name,
-        userAvatar: users.avatarUrl,
-        createdAt: interestChannelPosts.createdAt,
-        likeCount: interestChannelPosts.likeCount,
-        commentCount: interestChannelPosts.commentCount,
-        imageUrl: interestChannelPosts.imageUrl,
-        type: sql`'text'`
-      })
-      .from(interestChannelPosts)
-      .innerJoin(users, sql`${interestChannelPosts}.user_id = ${users.id}`)
-      .where(
-        and(
-          eq(interestChannelPosts.channelId, channelId),
-          eq(users.organizationId, req.user.organizationId || 1)
-        )
-      )
-      .orderBy(desc(interestChannelPosts.createdAt))
-      .limit(20);
-
-      res.json(posts);
-    } catch (error) {
-      console.error('Error fetching channel posts:', error);
-      res.status(500).json({ message: 'Failed to fetch posts' });
-    }
-  });
-
-  // Create a new post in channel
-  app.post('/api/channels/:id/posts', verifyToken, async (req: AuthenticatedRequest, res) => {
-    try {
-      if (!req.user) {
-        return res.status(401).json({ message: "Unauthorized" });
-      }
-
-      const channelId = parseInt(req.params.id);
-      
-      if (isNaN(channelId)) {
-        return res.status(400).json({ message: "Invalid channel ID" });
-      }
-
-      const { content } = req.body;
-
-      if (!content || content.trim().length === 0) {
-        return res.status(400).json({ message: "Content is required" });
-      }
-
-      // Verify channel exists and user has access
-      const [channel] = await db.select()
-        .from(interestChannels)
-        .where(
-          and(
-            eq(interestChannels.id, channelId),
-            eq(interestChannels.isActive, true),
-            eq(interestChannels.organizationId, req.user.organizationId || 1)
-          )
-        );
-
-      if (!channel) {
-        return res.status(404).json({ message: "Channel not found" });
-      }
-
-      // Check if user is a member of the channel
-      const [membership] = await db.select()
-        .from(interestChannelMembers)
-        .where(
-          and(
-            eq(interestChannelMembers.channelId, channelId),
-            eq(interestChannelMembers.userId, req.user.id)
-          )
-        );
-
-      if (!membership) {
-        return res.status(403).json({ message: "You must be a member of this space to create posts" });
-      }
-
-      // Create the post using raw SQL to match database schema
-      const result = await db.execute(sql`
-        INSERT INTO interest_channel_posts (channel_id, user_id, content, like_count, comment_count)
-        VALUES (${channelId}, ${req.user.id}, ${content.trim()}, 0, 0)
-        RETURNING *
-      `);
-      
-      const newPost = result.rows[0] || result[0];
-
-      res.status(201).json(newPost);
-    } catch (error) {
-      console.error('Error creating post:', error);
-      res.status(500).json({ message: 'Failed to create post' });
-    }
-  });
-
-  // Get channel members
-  app.get('/api/channels/:id/members', verifyToken, async (req: AuthenticatedRequest, res) => {
-    try {
-      if (!req.user) {
-        return res.status(401).json({ message: "Unauthorized" });
-      }
-
-      const channelId = parseInt(req.params.id);
-      
-      if (isNaN(channelId)) {
-        return res.status(400).json({ message: "Invalid channel ID" });
-      }
-
-      // Verify channel exists and user has access
-      const [channel] = await db.select()
-        .from(interestChannels)
-        .where(
-          and(
-            eq(interestChannels.id, channelId),
-            eq(interestChannels.isActive, true),
-            eq(interestChannels.organizationId, req.user.organizationId || 1)
-          )
-        );
-
-      if (!channel) {
-        return res.status(404).json({ message: "Channel not found" });
-      }
-
-      // Get channel members
-      const members = await db.select({
-        id: users.id,
-        name: users.name,
-        role: interestChannelMembers.role,
-        department: users.department,
-        location: users.location,
-        avatar: users.avatarUrl
-      })
-      .from(interestChannelMembers)
-      .innerJoin(users, eq(interestChannelMembers.userId, users.id))
-      .where(eq(interestChannelMembers.channelId, channelId))
-      .orderBy(users.name)
-      .limit(50);
-
-      res.json(members);
-    } catch (error) {
-      console.error('Error fetching channel members:', error);
-      res.status(500).json({ message: 'Failed to fetch members' });
-    }
-  });
-
-  // Get featured posts for channel discovery page
-  app.get('/api/channels/featured-posts', verifyToken, async (req: AuthenticatedRequest, res) => {
-    try {
-      if (!req.user) {
-        return res.status(401).json({ message: "Unauthorized" });
-      }
-
-      // Get all active channels with their latest posts
-      const channelsWithPosts = await db.select({
-        channelId: interestChannels.id,
-        channelName: interestChannels.name,
-        channelType: interestChannels.channelType,
-        postId: interestChannelPosts.id,
-        postContent: interestChannelPosts.content,
-        postImageUrl: interestChannelPosts.imageUrl,
-        postCreatedAt: interestChannelPosts.createdAt,
-        postLikeCount: interestChannelPosts.likeCount,
-        postCommentCount: interestChannelPosts.commentCount,
-        authorName: users.name,
-        authorAvatar: users.avatarUrl
-      })
-      .from(interestChannels)
-      .leftJoin(interestChannelPosts, eq(interestChannels.id, interestChannelPosts.channelId))
-      .leftJoin(users, eq(interestChannelPosts.authorId, users.id))
-      .where(
-        and(
-          eq(interestChannels.isActive, true),
-          eq(interestChannels.organizationId, req.user.organizationId || 1)
-        )
-      )
-      .orderBy(desc(interestChannelPosts.createdAt))
-      .limit(100);
-
-      // Group posts by channel and get the latest post for each
-      const channelPostsMap: Record<number, any> = {};
-      
-      channelsWithPosts.forEach(row => {
-        if (row.channelId && row.postId && !channelPostsMap[row.channelId]) {
-          channelPostsMap[row.channelId] = {
-            id: row.postId,
-            content: row.postContent,
-            imageUrl: row.postImageUrl,
-            createdAt: row.postCreatedAt,
-            likeCount: row.postLikeCount,
-            commentCount: row.postCommentCount,
-            authorName: row.authorName,
-            authorAvatar: row.authorAvatar,
-            channelName: row.channelName,
-            channelType: row.channelType
-          };
-        }
-      });
-
-      res.json(channelPostsMap);
-    } catch (error) {
-      console.error('Error fetching featured posts:', error);
-      res.status(500).json({ message: 'Failed to fetch featured posts' });
-    }
-  });
-
-  // Get channels suggestions
-  app.get('/api/channels/suggestions', verifyToken, async (req: AuthenticatedRequest, res) => {
-    try {
-      // For now, return channels the user hasn't joined
-      const userChannels = await db.select({ channelId: interestChannelMembers.channelId })
-        .from(interestChannelMembers)
-        .where(eq(interestChannelMembers.userId, Number(req.user?.id) || 0));
-
-      const userChannelIds = userChannels.map(uc => uc.channelId);
-
-      let suggestedChannels;
-      if (userChannelIds.length > 0) {
-        suggestedChannels = await db.select()
-          .from(interestChannels)
-          .where(
-            and(
-              eq(interestChannels.isActive, true),
-              sql`${interestChannels.id} NOT IN (${userChannelIds.join(',')})`
-            )
-          )
-          .limit(5);
-      } else {
-        suggestedChannels = await db.select()
-          .from(interestChannels)
-          .where(eq(interestChannels.isActive, true))
-          .limit(5);
-      }
-
-      res.json(suggestedChannels);
-    } catch (error) {
-      console.error('Error fetching suggested channels:', error);
-      res.status(500).json({ message: 'Failed to fetch suggested channels' });
-    }
-  });
-  
-  // Admin channels endpoint (for admin management)
-  app.get('/api/admin/channels', verifyToken, verifyAdmin, async (req: AuthenticatedRequest, res) => {
-    try {
-      if (!req.user) {
-        return res.status(401).json({ message: "Unauthorized" });
-      }
-
-      // Get all channels for the admin's organization
-      const channels = await db.select({
-        id: interestChannels.id,
-        name: interestChannels.name,
-        description: interestChannels.description,
-        channelType: interestChannels.channelType,
-        accessLevel: interestChannels.accessLevel,
-        memberCount: interestChannels.memberCount,
-        isActive: interestChannels.isActive,
-        allowedDepartments: interestChannels.allowedDepartments,
-        allowedSites: interestChannels.allowedSites,
-        createdAt: interestChannels.createdAt,
-        createdBy: interestChannels.createdBy
-      })
-      .from(interestChannels)
-      .where(eq(interestChannels.organizationId, req.user.organizationId || 1))
-      .orderBy(desc(interestChannels.createdAt));
-
-      res.json(channels);
-    } catch (error) {
-      console.error("Error fetching admin channels:", error);
-      res.status(500).json({ message: "Failed to fetch channels" });
-    }
-  });
-
-  // Create channel endpoint (admin)
-  app.post('/api/admin/channels', verifyToken, verifyAdmin, async (req: AuthenticatedRequest, res) => {
-    try {
-      if (!req.user) {
-        return res.status(401).json({ message: "Unauthorized" });
-      }
-
-      const {
-        name,
-        description,
-        channelType,
-        maxMembers,
-        isPrivate,
-        requiresApproval,
-        allowedDepartments = [],
-        allowedLocations = [],
-        autoAddMembers = false,
-        initialMembers = []
-      } = req.body;
-
-      // Validate required fields
-      if (!name || !channelType) {
-        return res.status(400).json({ message: "Channel name and type are required" });
-      }
-
-      // Determine access level based on privacy settings
-      let accessLevel = "open";
-      if (isPrivate) {
-        accessLevel = "invite_only";
-      } else if (requiresApproval) {
-        accessLevel = "approval_required";
-      } else if (allowedDepartments.length > 0) {
-        accessLevel = "department_only";
-      } else if (allowedLocations.length > 0) {
-        accessLevel = "site_only";
-      }
-
-      // Insert into interestChannels table
-      const [newChannel] = await db.insert(interestChannels).values({
-        name,
-        description,
-        channelType,
-        accessLevel,
-        allowedDepartments: allowedDepartments.length > 0 ? allowedDepartments : null,
-        allowedSites: allowedLocations.length > 0 ? allowedLocations : null,
-        isAutoCreated: false,
-        createdBy: req.user.id,
-        organizationId: req.user.organizationId || 1,
-        memberCount: 0
-      }).returning();
-
-      // Add initial members if specified
-      if (initialMembers.length > 0) {
-        const memberInserts = initialMembers.map((userId: number) => ({
-          channelId: newChannel.id,
-          userId,
-          role: 'member'
-        }));
-
-        await db.insert(interestChannelMembers).values(memberInserts);
-
-        // Update member count
-        await db.update(interestChannels)
-          .set({ memberCount: initialMembers.length })
-          .where(eq(interestChannels.id, newChannel.id));
-      }
-
-      // Auto-add members based on departments/locations if enabled
-      if (autoAddMembers && (allowedDepartments.length > 0 || allowedLocations.length > 0)) {
-        let whereConditions = [];
-
-        if (allowedDepartments.length > 0) {
-          whereConditions.push(inArray(users.department, allowedDepartments));
-        }
-
-        if (allowedLocations.length > 0) {
-          whereConditions.push(inArray(users.location, allowedLocations));
-        }
-
-        if (whereConditions.length > 0) {
-          const eligibleUsers = await db.select({ id: users.id })
-            .from(users)
-            .where(or(...whereConditions));
-
-          if (eligibleUsers.length > 0) {
-            const autoMemberInserts = eligibleUsers.map(user => ({
-              channelId: newChannel.id,
-              userId: user.id,
-              role: 'member'
-            }));
-
-            await db.insert(interestChannelMembers)
-              .values(autoMemberInserts)
-              .onConflictDoNothing();
-
-            // Update member count
-            await db.update(interestChannels)
-              .set({ memberCount: eligibleUsers.length })
-              .where(eq(interestChannels.id, newChannel.id));
-          }
-        }
-      }
-
-      res.status(201).json({ 
-        message: "Channel created successfully",
-        channel: newChannel 
-      });
-    } catch (error) {
-      console.error("Error creating channel:", error);
-      res.status(500).json({ message: "Failed to create channel" });
-    }
-  });
-
-  // Join channel endpoint
-  app.post('/api/channels/:id/join', verifyToken, async (req: AuthenticatedRequest, res) => {
-    try {
-      if (!req.user) {
-        return res.status(401).json({ message: "Unauthorized" });
-      }
-
-      const channelId = parseInt(req.params.id);
-      const { requestMessage } = req.body; // Optional message for approval-required channels
-      
-      // Get channel details
-      const [channel] = await db.select()
-        .from(interestChannels)
-        .where(eq(interestChannels.id, channelId));
-
-      if (!channel) {
-        return res.status(404).json({ message: "Channel not found" });
-      }
-
-      // Check if user is already a member
-      const existingMember = await db.select()
-        .from(interestChannelMembers)
-        .where(
-          and(
-            eq(interestChannelMembers.channelId, channelId),
-            eq(interestChannelMembers.userId, req.user.id)
-          )
-        );
-
-      if (existingMember.length > 0) {
-        return res.status(400).json({ message: "Already a member of this channel" });
-      }
-
-      // Check if there's already a pending join request
-      const existingRequest = await db.select()
-        .from(interestChannelJoinRequests)
-        .where(
-          and(
-            eq(interestChannelJoinRequests.channelId, channelId),
-            eq(interestChannelJoinRequests.userId, req.user.id),
-            eq(interestChannelJoinRequests.status, 'pending')
-          )
-        );
-
-      if (existingRequest.length > 0) {
-        return res.status(400).json({ message: "Join request already pending" });
-      }
-
-      // Handle different access levels
-      if (channel.accessLevel === 'approval_required') {
-        // Create join request for approval
-        await db.insert(interestChannelJoinRequests).values({
-          channelId,
-          userId: req.user.id,
-          requestMessage: requestMessage || null,
-          status: 'pending'
-        });
-
-        res.json({ message: "Join request submitted for approval" });
-      } else if (channel.accessLevel === 'invite_only') {
-        return res.status(403).json({ message: "This channel is invite-only. You need an invitation to join." });
-      } else {
-        // For open, department_only, and site_only channels - join directly
-        await db.insert(interestChannelMembers).values({
-          channelId,
-          userId: req.user.id,
-          role: 'member'
-        });
-
-        // Update member count
-        await db.update(interestChannels)
-          .set({ 
-            memberCount: sql`${interestChannels.memberCount} + 1`
-          })
-          .where(eq(interestChannels.id, channelId));
-
-        res.json({ message: "Successfully joined channel" });
-      }
-    } catch (error) {
-      console.error('Error joining channel:', error);
-      res.status(500).json({ message: 'Failed to join channel' });
-    }
-  });
-
-  // Leave channel endpoint
-  app.delete('/api/channels/:id/leave', verifyToken, async (req: AuthenticatedRequest, res) => {
-    try {
-      if (!req.user) {
-        return res.status(401).json({ message: "Unauthorized" });
-      }
-
-      const channelId = parseInt(req.params.id);
-      
-      // Remove user from channel
-      const result = await db.delete(interestChannelMembers)
-        .where(
-          and(
-            eq(interestChannelMembers.channelId, channelId),
-            eq(interestChannelMembers.userId, req.user.id)
-          )
-        );
-
-      // Update member count
-      await db.update(interestChannels)
-        .set({ 
-          memberCount: sql`${interestChannels.memberCount} - 1`
-        })
-        .where(eq(interestChannels.id, channelId));
-
-      res.json({ message: "Successfully left channel" });
-    } catch (error) {
-      console.error('Error leaving channel:', error);
-      res.status(500).json({ message: 'Failed to leave channel' });
-    }
-  });
-
-  // Get channel admins endpoint
-  app.get('/api/channels/:id/admins', verifyToken, async (req: AuthenticatedRequest, res) => {
-    try {
-      if (!req.user) {
-        return res.status(401).json({ message: "Unauthorized" });
-      }
-
-      const channelId = parseInt(req.params.id);
-      
-      const admins = await db.select({
-        id: users.id,
-        name: users.name,
-        username: users.username,
-        avatarUrl: users.avatarUrl,
-        department: users.department,
-        role: interestChannelMembers.role
-      })
-      .from(interestChannelMembers)
-      .innerJoin(users, eq(interestChannelMembers.userId, users.id))
-      .where(
-        and(
-          eq(interestChannelMembers.channelId, channelId),
-          eq(interestChannelMembers.role, 'admin')
-        )
-      );
-
-      res.json(admins);
-    } catch (error) {
-      console.error('Error fetching channel admins:', error);
-      res.status(500).json({ message: 'Failed to fetch channel admins' });
-    }
-  });
-
-  // Add channel admin endpoint
-  app.post('/api/channels/:id/admins', verifyToken, async (req: AuthenticatedRequest, res) => {
-    try {
-      if (!req.user) {
-        return res.status(401).json({ message: "Unauthorized" });
-      }
-
-      const channelId = parseInt(req.params.id);
-      const { userId } = req.body;
-
-      // Check if current user is an admin or channel creator
-      const [channel] = await db.select()
-        .from(interestChannels)
-        .where(eq(interestChannels.id, channelId));
-
-      if (!channel) {
-        return res.status(404).json({ message: "Channel not found" });
-      }
-
-      const [currentUserMember] = await db.select()
-        .from(interestChannelMembers)
-        .where(
-          and(
-            eq(interestChannelMembers.channelId, channelId),
-            eq(interestChannelMembers.userId, req.user.id)
-          )
-        );
-
-      if (channel.createdBy !== req.user.id && (!currentUserMember || currentUserMember.role !== 'admin')) {
-        return res.status(403).json({ message: "Only channel creators and admins can add new admins" });
-      }
-
-      // Update user role to admin
-      await db.update(interestChannelMembers)
-        .set({ role: 'admin' })
-        .where(
-          and(
-            eq(interestChannelMembers.channelId, channelId),
-            eq(interestChannelMembers.userId, userId)
-          )
-        );
-
-      res.json({ message: "User promoted to admin successfully" });
-    } catch (error) {
-      console.error('Error adding channel admin:', error);
-      res.status(500).json({ message: 'Failed to add channel admin' });
-    }
-  });
-
-  // Remove channel admin endpoint
-  app.delete('/api/channels/:id/admins/:userId', verifyToken, async (req: AuthenticatedRequest, res) => {
-    try {
-      if (!req.user) {
-        return res.status(401).json({ message: "Unauthorized" });
-      }
-
-      const channelId = parseInt(req.params.id);
-      const userId = parseInt(req.params.userId);
-
-      // Check if current user is an admin or channel creator
-      const [channel] = await db.select()
-        .from(interestChannels)
-        .where(eq(interestChannels.id, channelId));
-
-      if (!channel) {
-        return res.status(404).json({ message: "Channel not found" });
-      }
-
-      if (channel.createdBy !== req.user.id && req.user.id !== userId) {
-        return res.status(403).json({ message: "Only channel creators can remove admins, or admins can remove themselves" });
-      }
-
-      // Update user role to member
-      await db.update(interestChannelMembers)
-        .set({ role: 'member' })
-        .where(
-          and(
-            eq(interestChannelMembers.channelId, channelId),
-            eq(interestChannelMembers.userId, userId)
-          )
-        );
-
-      res.json({ message: "Admin removed successfully" });
-    } catch (error) {
-      console.error('Error removing channel admin:', error);
-      res.status(500).json({ message: 'Failed to remove channel admin' });
-    }
-  });
-
-  // Get join requests endpoint
-  app.get('/api/channels/:id/join-requests', verifyToken, async (req: AuthenticatedRequest, res) => {
-    try {
-      if (!req.user) {
-        return res.status(401).json({ message: "Unauthorized" });
-      }
-
-      const channelId = parseInt(req.params.id);
-      
-      // Check if user is admin or channel creator
-      const [channel] = await db.select()
-        .from(interestChannels)
-        .where(eq(interestChannels.id, channelId));
-
-      if (!channel) {
-        return res.status(404).json({ message: "Channel not found" });
-      }
-
-      const [currentUserMember] = await db.select()
-        .from(interestChannelMembers)
-        .where(
-          and(
-            eq(interestChannelMembers.channelId, channelId),
-            eq(interestChannelMembers.userId, req.user.id)
-          )
-        );
-
-      if (channel.createdBy !== req.user.id && (!currentUserMember || currentUserMember.role !== 'admin')) {
-        return res.status(403).json({ message: "Only channel creators and admins can view join requests" });
-      }
-
-      const joinRequests = await db.select({
-        id: interestChannelJoinRequests.id,
-        userId: interestChannelJoinRequests.userId,
-        status: interestChannelJoinRequests.status,
-        requestMessage: interestChannelJoinRequests.requestMessage,
-        createdAt: interestChannelJoinRequests.createdAt,
-        userName: users.name,
-        userUsername: users.username,
-        userAvatarUrl: users.avatarUrl,
-        userDepartment: users.department
-      })
-      .from(interestChannelJoinRequests)
-      .innerJoin(users, eq(interestChannelJoinRequests.userId, users.id))
-      .where(
-        and(
-          eq(interestChannelJoinRequests.channelId, channelId),
-          eq(interestChannelJoinRequests.status, 'pending')
-        )
-      )
-      .orderBy(desc(interestChannelJoinRequests.createdAt));
-
-      res.json(joinRequests);
-    } catch (error) {
-      console.error('Error fetching join requests:', error);
-      res.status(500).json({ message: 'Failed to fetch join requests' });
-    }
-  });
-
-  // Approve/reject join request endpoint
-  app.patch('/api/channels/:id/join-requests/:requestId', verifyToken, async (req: AuthenticatedRequest, res) => {
-    try {
-      if (!req.user) {
-        return res.status(401).json({ message: "Unauthorized" });
-      }
-
-      const channelId = parseInt(req.params.id);
-      const requestId = parseInt(req.params.requestId);
-      const { status, reviewMessage } = req.body; // 'approved' or 'rejected'
-
-      // Check if user is admin or channel creator
-      const [channel] = await db.select()
-        .from(interestChannels)
-        .where(eq(interestChannels.id, channelId));
-
-      if (!channel) {
-        return res.status(404).json({ message: "Channel not found" });
-      }
-
-      const [currentUserMember] = await db.select()
-        .from(interestChannelMembers)
-        .where(
-          and(
-            eq(interestChannelMembers.channelId, channelId),
-            eq(interestChannelMembers.userId, req.user.id)
-          )
-        );
-
-      if (channel.createdBy !== req.user.id && (!currentUserMember || currentUserMember.role !== 'admin')) {
-        return res.status(403).json({ message: "Only channel creators and admins can approve join requests" });
-      }
-
-      // Get the join request
-      const [joinRequest] = await db.select()
-        .from(interestChannelJoinRequests)
-        .where(eq(interestChannelJoinRequests.id, requestId));
-
-      if (!joinRequest) {
-        return res.status(404).json({ message: "Join request not found" });
-      }
-
-      // Update join request status
-      await db.update(interestChannelJoinRequests)
-        .set({
-          status,
-          reviewedBy: req.user.id,
-          reviewedAt: new Date(),
-          reviewMessage
-        })
-        .where(eq(interestChannelJoinRequests.id, requestId));
-
-      // If approved, add user to channel
-      if (status === 'approved') {
-        await db.insert(interestChannelMembers).values({
-          channelId,
-          userId: joinRequest.userId,
-          role: 'member'
-        });
-
-        // Update member count
-        await db.update(interestChannels)
-          .set({ 
-            memberCount: sql`${interestChannels.memberCount} + 1`
-          })
-          .where(eq(interestChannels.id, channelId));
-      }
-
-      res.json({ message: `Join request ${status} successfully` });
-    } catch (error) {
-      console.error('Error processing join request:', error);
-      res.status(500).json({ message: 'Failed to process join request' });
-    }
-  });
-
-  // Remove member endpoint (admin only)
-  app.delete('/api/channels/:id/members/:userId', verifyToken, async (req: AuthenticatedRequest, res) => {
-    try {
-      if (!req.user) {
-        return res.status(401).json({ message: "Unauthorized" });
-      }
-
-      const channelId = parseInt(req.params.id);
-      const userId = parseInt(req.params.userId);
-
-      // Check if user is admin or channel creator
-      const [channel] = await db.select()
-        .from(interestChannels)
-        .where(eq(interestChannels.id, channelId));
-
-      if (!channel) {
-        return res.status(404).json({ message: "Channel not found" });
-      }
-
-      const [currentUserMember] = await db.select()
-        .from(interestChannelMembers)
-        .where(
-          and(
-            eq(interestChannelMembers.channelId, channelId),
-            eq(interestChannelMembers.userId, req.user.id)
-          )
-        );
-
-      if (channel.createdBy !== req.user.id && (!currentUserMember || currentUserMember.role !== 'admin')) {
-        return res.status(403).json({ message: "Only channel creators and admins can remove members" });
-      }
-
-      // Don't allow removing the channel creator
-      if (userId === channel.createdBy) {
-        return res.status(400).json({ message: "Cannot remove channel creator" });
-      }
-
-      // Remove user from channel
-      await db.delete(interestChannelMembers)
-        .where(
-          and(
-            eq(interestChannelMembers.channelId, channelId),
-            eq(interestChannelMembers.userId, userId)
-          )
-        );
-
-      // Update member count
-      await db.update(interestChannels)
-        .set({ 
-          memberCount: sql`${interestChannels.memberCount} - 1`
-        })
-        .where(eq(interestChannels.id, channelId));
-
-      res.json({ message: "Member removed successfully" });
-    } catch (error) {
-      console.error('Error removing member:', error);
-      res.status(500).json({ message: 'Failed to remove member' });
-    }
-  });
-
-  app.use((err: any, _req: Request, res: Response, _next: NextFunction) => {
-    console.error(err.stack);
-    res.status(500).send('Something broke!');
-  });
-
-  const httpServer = createServer(app);
-  return httpServer;
-}
